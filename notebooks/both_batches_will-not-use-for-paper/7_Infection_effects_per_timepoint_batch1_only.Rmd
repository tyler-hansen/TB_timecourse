---
title: "Linear modeling of RNA-seq data with Limma-Voom: Infection vs. Time"
output:
  html_document:
    df_print: paged
---
Author: Tyler Hansen
Date: 4.17.2024

This notebook specifically looks at the effect of the infection for all timepoints and this effect at each timepoint. Ancestry relate analysis will come later. Importantly, this only uses batch1 samples, sinc batch2 were deemed poor. 

In the previous notebook, I tried to identify how best to model my data. 

I will first model global effects and run gsea. Then I will model the infection at each timepoint using a nested model (Timepoint:Infection). 

I will then identify DEGs per timepoint and report. 

I will then extract betas from each timepoint, mean-center them, and then cluster by their behavior using hclust and kmeans. I will then run pathway enrichment overrepresentation analysis on the individual clusters to see which pathways they represent. 

## Setup

Packages
```{r}
suppressPackageStartupMessages(library(tidyverse))
library(limma)
library(edgeR)
```

Three tables
```{r}
#read in GTF
gtf <- rtracklayer::readGFFAsGRanges("data/Homo_sapiens.GRCh38.87.gtf")

#read in SI
sample_info <- readRDS("data/metadata_batch1-only_approach1_all-samples.rds")

#read in cts
cts <- readRDS("data/cts_batch1-only_approach1_all-samples.rds")
```

## Model infection:

Model: ~ 0 + Infection + Timepoint + Donor_ID + technical confounders[perc_GC + perc_Aligned + perc_Dups + flow_cell]

Beta of Infection is the effect due to infection
Beta of Timepoint is the effect due to timepoint variability (categorical)
Beta of Donor_ID is the effect due to donor-to-donor variability

### Read in sample info and set design

I want to model the infection, to identify genes that respond to infection at all timepoints across all donors. The covariates here are GC, Dups, Aligned, and flow_cell.
```{r}
#set design matrix. 
design <- model.matrix(~ 0 + Infection + Timepoint + Donor_ID + perc_GC + perc_Aligned + perc_Dups + flow_cell, data = sample_info)
```

### Voom transform
Now that the counts are filtered, perform the voom tramsformation. 
```{r}
#if match, then this will print true
all(rownames(design) == colnames(cts))

#make dgelist again and voom transform
dge <- DGEList(cts)
dge <- calcNormFactors(dge)
v <- voom(dge, design, plot = T)
```

### Fit model and compute empirical bayes statistics for contrasts
```{r}
#fit model
vfit <-lmFit(v, design)

#make contrasts and apply to model
contrast.matrix <- makeContrasts(InfectionMtb-InfectionNI, levels = coef(vfit))
vfit <- contrasts.fit(vfit, contrasts=contrast.matrix)

#compute stats
vfit <- eBayes(vfit)
```

### Plot residual variance vs. expression SA plot

```{r}
plotSA(vfit)
```

Sigma is the estimated residual standard deviation, so the variance is no longer dependent on the mean expression level. 

### Verify model is working correctly by extracting top hits and plotting their voom transformed counts.
```{r}
#get top hits with topTable
res <- topTable(vfit, number = 100)
top <- row.names(res)[1:4]

#subset v by top rownames
top_v <- v$E[top, ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id")

#pivot longer
top_v <- pivot_longer(top_v, cols = !gene_id, names_to = "sample", values_to = "voom_cts")

#add metadata by joining with sample_info (move rownames to col first)
top_v <- left_join(top_v, rownames_to_column(sample_info, var = "sample"), by = "sample")

#convert gene_id to symbol
top_v <- mutate(top_v, symbol = str_split_i(gene_id, pattern = "_", i = 2))

# plot box plot of counts by time for each infection status
ggplot(top_v, aes(x = Infection, y = voom_cts)) +
  geom_jitter(aes(color = Infection), alpha = 0.5) +
  geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
  facet_wrap(~symbol, ncol = 4, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```
Great! These capture the Infection difference, but only upregulated genes are shown. 

Try getting downregulated genes:
```{r}
#get top hits with topTable
res <- topTable(vfit, number = Inf) %>% dplyr::filter(logFC < 0)
top <- row.names(res)[1:4]

#subset v by top rownames
top_v <- v$E[top, ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id")

#pivot longer
top_v <- pivot_longer(top_v, cols = !gene_id, names_to = "sample", values_to = "voom_cts")

#add metadata by joining with sample_info (move rownames to col first)
top_v <- left_join(top_v, rownames_to_column(sample_info, var = "sample"), by = "sample")

#convert gene_id to symbol
top_v <- mutate(top_v, symbol = str_split_i(gene_id, pattern = "_", i = 2))

# plot box plot of counts by time for each infection status
ggplot(top_v, aes(x = Infection, y = voom_cts)) +
  geom_jitter(aes(color = Infection), alpha = 0.5) +
  geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
  facet_wrap(~symbol, ncol = 4, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```

Great!

### GSEA global

Which pathways are differentially regulated?
```{r}
#load Human Molecular Signatures Database (msigdb) pathways
hallmark_pathways <- fgsea::gmtPathways("../../common-use-files/msigdb_pathways/h.all.v2023.2.Hs.symbols.gmt")

#rank by t stat
res <- topTable(vfit, number = Inf)
res_rank <- dplyr::arrange(res, t) %>% rownames_to_column("gene_id")

#isolate symbol from rownames
res_rank <- mutate(res_rank, symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% distinct()

#make rank vector
ranks <- res_rank$t
names(ranks) <- res_rank$symbol

#run fgsea
fgseaRes <- fgsea::fgsea(hallmark_pathways, ranks)
```

Plot hallmark pathways
```{r, fig.dim=c(10,8)}
topPathwaysUp <- fgseaRes[ES > 0][head(order(pval), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(pval), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
all_gsea_plot <- fgsea::plotGseaTable(hallmark_pathways[topPathways], ranks, fgseaRes, gseaParam=0.5)
all_gsea_plot
```
So there are immune related pathways shown here: Interferon alpha/gamma response | Inflammatory response | TGF beta signaling

What is happening to key Macrophage Markers?
```{r,fig.width=8, fig.height=20}
#convert voom table to long format and add metadata and convert gene_id to symbol (I did this above previously in a clearer way).
top_v <- v$E %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>%
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2))

#select the genes we care about:
top_v <- filter(top_v, symbol %in% c("TNF", "IL1A", "IL1B", "IL6", "IL4", "IL10", "IL12A", "IL12B", "IL18", "IL23", "IL27", "TGFB1",
                                     "CXCL1", "CXCL2", "CCL5", "CXCL8", "CXCL9", "CXCL10", "CXCL10", "HLA-DRA", "HLA-DRB1", "CD80", "CD86", 
                                     "NFKB1", "NFKB2", "RELA", "RELB", "REL")) 

#order timepoint:
top_v$Timepoint <- factor(top_v$Timepoint, levels = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48"))

# plot box plot of counts by time for each infection status
ggplot(top_v, aes(x = Timepoint, y = voom_cts)) +
  geom_boxplot(aes(fill = Infection)) +
  facet_wrap(~symbol, ncol = 3, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  theme_bw()

# plot line plot of counts by time for each infection status. Include jittered points. 
mf_regs_plot <- ggplot(top_v, aes(x = Timepoint_hr, y = voom_cts)) +
  geom_jitter(aes(group=Infection, color = Infection), alpha = 0.25) +
  geom_smooth(aes(group=Infection, color = Infection)) +
  facet_wrap(~symbol, ncol = 3, scales = "free") +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
mf_regs_plot

#combine:
ggplot(top_v, aes(x = Timepoint, y = voom_cts)) +
  geom_smooth(aes(group=Infection, color = Infection), se = F) +
  geom_boxplot(aes(fill = Infection)) +
  facet_wrap(~symbol, ncol = 3, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```
Hard to tell from the plots in the document, but this is very cool when we blow it up. There are different patterns for these cytokines/factors. 

What is happening to key Cell Cycle Markers?
```{r,fig.width=8, fig.height=20}
#convert voom table to long format and add metadata and convert gene_id to symbol (I did this above previously in a clearer way).
top_v <- v$E %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>%
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2))

#select the genes we care about:
top_v <- filter(top_v, symbol %in% c("TP53", "MYC", "E2F1", "E2F2", "E2F3", "E2F4", "E2F5", "E2F6", "E2F7", "E2F8", "RB1", "CDK1", "CDK2", "CDK4", "CDK6", "CCNA2", "CCNA2", "CCND1", "CCNB1", "CCNE1")) 

#order timepoint:
top_v$Timepoint <- factor(top_v$Timepoint, levels = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48"))

# plot box plot of counts by time for each infection status
ggplot(top_v, aes(x = Timepoint, y = voom_cts)) +
  geom_boxplot(aes(fill = Infection)) +
  facet_wrap(~symbol, ncol = 3, scales = "free") +
  scale_fill_manual(values = c("grey", "blue")) +
  theme_bw()

# plot line plot of counts by time for each infection status. Include jittered points. 
cell_cycle_plot <- ggplot(top_v, aes(x = Timepoint_hr, y = voom_cts)) +
  geom_jitter(aes(group=Infection, color = Infection), alpha = 0.25) +
  geom_smooth(aes(group=Infection, color = Infection)) +
  facet_wrap(~symbol, ncol = 3, scales = "free") +
  scale_color_manual(values = c("grey", "blue")) +
  theme_bw()
cell_cycle_plot

#combine:
ggplot(top_v, aes(x = Timepoint, y = voom_cts)) +
  geom_smooth(aes(group=Infection, color = Infection), se = F) +
  geom_boxplot(aes(fill = Infection)) +
  facet_wrap(~symbol, ncol = 3, scales = "free") +
  scale_fill_manual(values = c("grey", "blue")) +
  scale_color_manual(values = c("grey", "blue")) +
  theme_bw()
```

Woah, it looks like TB actually inhibits the expression of cell cycle regulators? Especially TP53 and RB1, they have all donors displaying this behavior. This is a little odd since the pathogen is heatkilled in this case. It should really just simulate an immune response. In this way, the macrophage might respond by arresting the cell cycle to focus on the infection? Either way, this likely explains why cell cylce pathways are the most differentially expressed pathways. 

Next plan is to model looking at timepoint-infection effect to identify differences at each Timepoint.  

## Model infection:timepoint nested model:

Model: ~ 0 + Timepoint:Infection + Timepoint + Donor_ID + perc_GC + perc_Dups + perc_Aligned + flow_cell

### Fit data to model
#### Read in sample info and set design

I want to model the infection, to identify genes that respond to infection at all timepoints across all donors. The covariates here are GC, Dups, Aligned, and flow_cell. See EDA_limma.Rmd for PCAs and UMAPs.

By including timepoint, we estimate the "main effects" from the timepoint variable and regress that out. In doing this it also estimates an intercept for each timepoint. Plus, without timepoint, it reports coeficients for all combinatinos of timepoint and infection. 
```{r}
#set design matrix for filtered data and all
design_nested <- model.matrix( ~ 0 + Timepoint:Infection + Timepoint + Donor_ID + perc_GC + perc_Dups + perc_Aligned + flow_cell, data = sample_info)
```

#### Fit model and compute empirical bayes statistics for contrasts
```{r}
#fit model
vfit_nested <-lmFit(v, design_nested)

#compute stats
vfit_nested <- eBayes(vfit_nested)
```

#### Plot residual variance vs. expression SA plot
```{r}
plotSA(vfit_nested)
```

#### Check that model is working per timepoint

```{r}
#T1
res <- topTable(vfit_nested, coef = "TimepointT1:InfectionMtb", number = 3)
top_v <- v$E[row.names(res), ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>% 
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% dplyr::filter(Timepoint == "T1")
ggplot(top_v, aes(x = Infection, y = voom_cts)) +
  geom_jitter(aes(color = Infection), alpha = 0.5) +
  geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
  facet_wrap(~symbol, ncol = 4, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```
```{r}
#T3
res <- topTable(vfit_nested, coef = "TimepointT3:InfectionMtb", number = 3)
top_v <- v$E[row.names(res), ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>% 
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% dplyr::filter(Timepoint == "T3")
ggplot(top_v, aes(x = Infection, y = voom_cts)) +
  geom_jitter(aes(color = Infection), alpha = 0.5) +
  geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
  facet_wrap(~symbol, ncol = 4, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```
```{r}
#T5
res <- topTable(vfit_nested, coef = "TimepointT5:InfectionMtb", number = 3)
top_v <- v$E[row.names(res), ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>% 
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% dplyr::filter(Timepoint == "T5")
ggplot(top_v, aes(x = Infection, y = voom_cts)) +
  geom_jitter(aes(color = Infection), alpha = 0.5) +
  geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
  facet_wrap(~symbol, ncol = 4, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```
```{r}
#T8
res <- topTable(vfit_nested, coef = "TimepointT8:InfectionMtb", number = 3)
top_v <- v$E[row.names(res), ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>% 
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% dplyr::filter(Timepoint == "T8")
ggplot(top_v, aes(x = Infection, y = voom_cts)) +
  geom_jitter(aes(color = Infection), alpha = 0.5) +
  geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
  facet_wrap(~symbol, ncol = 4, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```
```{r}
#T12
res <- topTable(vfit_nested, coef = "TimepointT12:InfectionMtb", number = 3)
top_v <- v$E[row.names(res), ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>% 
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% dplyr::filter(Timepoint == "T12")
ggplot(top_v, aes(x = Infection, y = voom_cts)) +
  geom_jitter(aes(color = Infection), alpha = 0.5) +
  geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
  facet_wrap(~symbol, ncol = 4, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```
```{r}
#T18
res <- topTable(vfit_nested, coef = "TimepointT18:InfectionMtb", number = 3)
top_v <- v$E[row.names(res), ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>% 
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% dplyr::filter(Timepoint == "T18")
ggplot(top_v, aes(x = Infection, y = voom_cts)) +
  geom_jitter(aes(color = Infection), alpha = 0.5) +
  geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
  facet_wrap(~symbol, ncol = 4, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```
```{r}
#T24
res <- topTable(vfit_nested, coef = "TimepointT24:InfectionMtb", number = 3)
top_v <- v$E[row.names(res), ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>% 
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% dplyr::filter(Timepoint == "T24")
ggplot(top_v, aes(x = Infection, y = voom_cts)) +
  geom_jitter(aes(color = Infection), alpha = 0.5) +
  geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
  facet_wrap(~symbol, ncol = 4, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```
```{r}
#T30
res <- topTable(vfit_nested, coef = "TimepointT30:InfectionMtb", number = 3)
top_v <- v$E[row.names(res), ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>% 
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% dplyr::filter(Timepoint == "T30")
ggplot(top_v, aes(x = Infection, y = voom_cts)) +
  geom_jitter(aes(color = Infection), alpha = 0.5) +
  geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
  facet_wrap(~symbol, ncol = 4, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```
```{r}
#T36
res <- topTable(vfit_nested, coef = "TimepointT36:InfectionMtb", number = 3)
top_v <- v$E[row.names(res), ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>% 
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% dplyr::filter(Timepoint == "T36")
ggplot(top_v, aes(x = Infection, y = voom_cts)) +
  geom_jitter(aes(color = Infection), alpha = 0.5) +
  geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
  facet_wrap(~symbol, ncol = 4, scales = "free") +
  scale_fill_manual(values = c("grey", "red")) +
  scale_color_manual(values = c("grey", "red")) +
  theme_bw()
```

### Compute emperical p values and apply the story fdr correction to these values
The q value adjustment for multiple testing correction seems to be the superior method to FWER and Benjamini-Hochberg. The only issue with it is when the pvalue distribution is not uniform. In most cases, this is fine, but it is best to use an empirical approach where the pvalues are first corrected based on null pvalues obtained from permutations. 

To do this, we have the following steps:
1. Permute the variable of interest and calculate the null pvalues, for at least 10 iterations.
2. Adjust the observed pvalues based on the null/expected pvalues using the emPvals() function from the qvalue package. 
3. Use the adjusted p values to calculate storey q values. Use these to threshold genes. 

#### Permute the variable of interest and calculate the null pvalues, for at least 10 iterations. 
Permute the the infection column within timepoint so that infection is random and the null is the random effect of that. 
```{r}
#function to permute the variable of interest
permute_si_variable_within_category <- function(var, si, cat, n = 10) {
  # var is the variable of interest
  # si is the sample info/metadata
  # cat is the category/variable to permute within (must be a factor)
  # n is the number of iterations
  # this function returns a list of permuted sample info data.frames 
  
  # create dummy list
  list_x <- list()
  
  #split the si into the individual factors of the cat and permute var
  for (category in levels(sample_info[,cat])) {
    #split si
    x <- sample_info[sample_info[,cat] == category, ]
    
    #permute
    x <- rsample::permutations(x, permute = all_of(var), times = n)
    
    #add to list
    list_x[[category]] <- x
  }

  #for each iteration, extract permutations for each timepoint and join back together
  
  #make another dummy list
  list_y <- list()
  
  for (i in seq(1, n)) {
    #make dummy df 
    df <- data.frame()
    
    for (category in levels(sample_info[,cat])) {
        x <- list_x[[category]] 
        x <- x$splits[[i]] %>% rsample::analysis() %>% as.data.frame()
        df <- rbind(df, x)
    }
    
    #add df to list
    list_y[[i]] <- df
  }
  #return the list
  return(list_y)
}
```

```{r}
#execute function:
permuted_si_perTime <- permute_si_variable_within_category(var = "Infection", si = sample_info, cat = "Timepoint", n = 10)
```

Fit permuted data to linear models, use the same model as done in the observed analysis
```{r}
fit_permutations <- function(perms, formula, v, n =  10) {
  # perms is the permuted sample info
  # formula is the formula used in the respective analysis provided in quotes (ex: "~ Timepoint")
  # v are the voom tramsformed counts to input into the random/null models. 
  # n is the number of iterations performed above. 
  # Returns a list of model fits for the permuted data
  
  # create dummy list
  list_x <- list()
  
  #extract each iteration and set_up random models:
    for (i in seq(1, n)) {
      #set up model for ith iteration
      m_rand <- model.matrix(as.formula(formula), data = as.data.frame(perms[i]))
    
      #fit model for each iteration
      vfit_rand <- lmFit(v, m_rand)
      
      #compute stats
      vfit_rand <- eBayes(vfit_rand)
      
      #add to list
      list_x <- rlist::list.append(list_x, vfit_rand)
    }
  return(list_x)
}
```

```{r}
permuted_fits <- fit_permutations(perms = permuted_si_perTime, formula = "~ 0 + Timepoint:Infection + Timepoint + Donor_ID + perc_GC + perc_Dups + perc_Aligned + flow_cell ", v = v, n = 10)
```

Calculate null pvalues
```{r}
get_null_pvals <- function(perm_fits, n =  10) {
  # perm_fits is the list of model fits for permuted data
  # n is the number of iterations performed above. 
  # cat is the category/variable that was permuted within (must be a factor). This is used to identify the individual categories to get pvalues for. 
  # Returns a vector of pvalues for the contrast between Mtb and NI
  
  # create dummy df
  df <- data.frame()
  
  #for each iteration, extract the null pvalues between NI and Mtb:
    for (i in seq(1, n)) {
      #for each iteration, append p.vals to the dummy df
      x <- as.data.frame(perm_fits[[i]]$p.value)
      df <- dplyr::bind_rows(df, x)
    }
  return(df)
}
```

```{r}
null_pvalues <- get_null_pvals(perm_fits = permuted_fits, n = 10)
```

Check the distribution of null pvalues
```{r}
hist(as.matrix(null_pvalues)[, 37:55])
hist(vfit_nested$p.value[, 37:55])
```


For each nested model, calculate p-values from a set of observed test statistics and simulated null test statistics. 

Note: the output of empPval needs to be corrected by 1-value. Tauras explained this is because the function expects effect sizes by default, so it returns the proportion which are larger. If I were to plot empP vs. P, I'd find they're inversely correlated. 

```{r}
#make pval and se dfs
obs_pvals <- as.data.frame(vfit_nested$p.value)
SE <- sqrt(vfit_nested$s2.post) * vfit_nested$stdev.unscaled


#setup list to iterate through
timepoint_list <- list()
for (t in c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48")) {
  time <- paste0("Timepoint", t, ":InfectionMtb")
  timepoint_list <- append(timepoint_list, time)
}

#run through list to extract qvalues for each
for (i in timepoint_list) {
  emperical_pvals <- qvalue::empPvals(stat = -log10(obs_pvals[, i]), stat0 = -log10(null_pvalues[, i]), pool = T)
  qvals <- qvalue::qvalue(p = emperical_pvals)
  
  #merge
  tmp1 <- data.frame(obs_pval = obs_pvals[, i], empirical_qval = qvals$qvalues)
  
  #get pvalues just for the timepoint
  tmp2 <- dplyr::select(obs_pvals, all_of(i))
  colnames(tmp2) <- "p.value"
  
  #join to each gene
  tmp3 <- bind_cols(tmp2, tmp1) %>% rownames_to_column("gene_id")
  
  #stop if the row order is not the same
  if (all(tmp3$p.value == tmp3$obs_pval) == FALSE) {
    stop()
  }
  
  #remove redundant col
  tmp3 <- dplyr::select(tmp3, -p.value)
  
  #get the stats
  tmp4 <- data.frame(coefficients = c(vfit_nested$coefficients[, i]), 
                     t_statistic = c(vfit_nested$t[, i]), 
                     coef_se = c(SE[, i]), 
                     p.value = c(vfit_nested$p.value[, i])) %>% rownames_to_column("gene_id")
  
  #join
  tmp5 <- inner_join(tmp4, tmp3, by = "gene_id")
  
  #stop if join doesn't work properly
  if (all(tmp5$p.value == tmp5$obs_pval) == FALSE) {
    stop()
  }
  #remove redundant col 
  tmp5 <- dplyr::select(tmp5, -obs_pval)

  #assign ttmp5
  assign(value = tmp5, x = paste0(i, "_results"))
  
  #remove tmps
  rm(tmp1, tmp2, tmp3, tmp4, tmp5)
}
```

### Number of DEGs per timepoint
Now that we have emprical qvalues, we will threshold with LFC and a qval.

Plot distributions to make an educated choice on the threshold. 
```{r}
hist(`TimepointT1:InfectionMtb_results`$empirical_qval, breaks = 100)
hist(`TimepointT3:InfectionMtb_results`$empirical_qval, breaks = 100)
hist(`TimepointT5:InfectionMtb_results`$empirical_qval, breaks = 100)
hist(`TimepointT8:InfectionMtb_results`$empirical_qval, breaks = 100)
hist(`TimepointT12:InfectionMtb_results`$empirical_qval, breaks = 100)
hist(`TimepointT18:InfectionMtb_results`$empirical_qval, breaks = 100)
hist(`TimepointT24:InfectionMtb_results`$empirical_qval, breaks = 100)
hist(`TimepointT30:InfectionMtb_results`$empirical_qval, breaks = 100)
hist(`TimepointT36:InfectionMtb_results`$empirical_qval, breaks = 100)
hist(`TimepointT48:InfectionMtb_results`$empirical_qval, breaks = 100)
```

Probably 0.01 is the best q val threshold. 

LFC
```{r}
hist(`TimepointT1:InfectionMtb_results`$coefficients, breaks = 100)
hist(`TimepointT3:InfectionMtb_results`$coefficients, breaks = 100)
hist(`TimepointT5:InfectionMtb_results`$coefficients, breaks = 100)
hist(`TimepointT8:InfectionMtb_results`$coefficients, breaks = 100)
hist(`TimepointT12:InfectionMtb_results`$coefficients, breaks = 100)
hist(`TimepointT18:InfectionMtb_results`$coefficients, breaks = 100)
hist(`TimepointT24:InfectionMtb_results`$coefficients, breaks = 100)
hist(`TimepointT30:InfectionMtb_results`$coefficients, breaks = 100)
hist(`TimepointT36:InfectionMtb_results`$coefficients, breaks = 100)
hist(`TimepointT36:InfectionMtb_results`$coefficients, breaks = 100)
```

Yeah +/-1 is probably right. 

Report number of DEGs via qval
```{r}
dplyr::filter(`TimepointT1:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT2:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT3:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT4:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT5:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT6:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT7:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT8:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT9:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT10:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT12:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT14:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT16:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT18:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT24:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT30:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT36:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT42:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
dplyr::filter(`TimepointT48:InfectionMtb_results`, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1)) %>% nrow()
```

Plot
```{r, fig.width=8, fig.height=5}
number_DEGs <- data.frame(Time = factor(x = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48"), 
                                   levels = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48")), 
                              number_DEGs = c(216, 1088, 2143, 2662, 2649, 2494, 2612, 2461, 2417, 2514, 2064, 2108, 2091, 2055, 1982, 1910, 2005, 2019, 2121))

degs_plot <- ggplot(number_DEGs, aes(x = Time, y = number_DEGs, group = 1)) +
  geom_line(color="grey20") +
  geom_point(size = 3) +
  geom_text(aes(label = number_DEGs), vjust = 0, hjust=-0.2, angle = 45) +
  labs(y = "Number of DEGs", x  ="Timepoint (hrs)",
       title = "Number of genes responding to Mtb infection per timepoint", 
       subtitle = "Thresholds: LogFC +/-1 & qvalue < 0.001") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"), plot.subtitle = element_text(hjust = 0.5, face = "italic")) +
  coord_cartesian(ylim = c(0, 2800))

degs_plot
```

Now report number without LFC filter: 
```{r}
dplyr::filter(`TimepointT1:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT2:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT3:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT4:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT5:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT6:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT7:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT8:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT9:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT10:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT12:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT14:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT16:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT18:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT24:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT30:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT36:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT42:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
dplyr::filter(`TimepointT48:InfectionMtb_results`, empirical_qval < 0.01 ) %>% nrow()
```

Plot
```{r}
number_DEGs <- data.frame(Time = factor(x = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48"), 
                                   levels = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48")), 
                              number_DEGs = c(831, 6628, 8047, 8944, 9438, 6664, 7578, 8508, 7049, 8223, 7473, 6788, 5338, 6455, 7882, 7253, 8045, 8272, 8597))

degs_plot <- ggplot(number_DEGs, aes(x = Time, y = number_DEGs, group = 1)) +
  geom_line(color="grey20") +
  geom_point(size = 3) +
  geom_text(aes(label = number_DEGs), vjust = -0.75, hjust=0.5, angle = 0) +
  labs(y = "Number of DEGs", x  ="Timepoint (hrs)",
       title = "Number of genes responding to Mtb infection per timepoint", 
       subtitle = "Thresholds: q-value < 0.001") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"), plot.subtitle = element_text(hjust = 0.5, face = "italic")) +
  coord_cartesian(ylim = c(0, 11000))

degs_plot
```

This is almost every gene. This seems a little much. Save DEGs from stringent threshold. 

Save DEGs for all timepoints and indiividual timepoints:
```{r}
timepoint_results_list <- list("T1" = `TimepointT1:InfectionMtb_results`, "T2" = `TimepointT2:InfectionMtb_results`, "T3" = `TimepointT3:InfectionMtb_results`, "T4" = `TimepointT4:InfectionMtb_results`, 
                               "T5" = `TimepointT5:InfectionMtb_results`, "T6" = `TimepointT6:InfectionMtb_results`, "T7" = `TimepointT7:InfectionMtb_results`, "T8" = `TimepointT8:InfectionMtb_results`, 
                               "T9" = `TimepointT9:InfectionMtb_results`, "T10" = `TimepointT10:InfectionMtb_results`, "T12" = `TimepointT12:InfectionMtb_results`, "T14" = `TimepointT14:InfectionMtb_results`, 
                               "T16" = `TimepointT16:InfectionMtb_results`, "T18" = `TimepointT18:InfectionMtb_results`, "T24" = `TimepointT24:InfectionMtb_results`, "T30" = `TimepointT30:InfectionMtb_results`, 
                               "T36" = `TimepointT36:InfectionMtb_results`, "T42" = `TimepointT42:InfectionMtb_results`, "T48" = `TimepointT48:InfectionMtb_results`)

for (i in c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48")) {
  tmp <- timepoint_results_list[[i]]
  tmp <- dplyr::filter(tmp, empirical_qval < 0.01 & (coefficients > 1 | coefficients < -1))
  saveRDS(tmp, file = paste0("results/timepoint_specific_", i, "_DEGs.RDS"))
  assign(value = tmp, x = paste0("DEGs_", i))
  rm(tmp)
}


DEGs_all <- data.frame()
for (i in c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48")) {
  tmp_degs <- get(paste0("DEGs_", i))
  DEGs_all <- bind_rows(DEGs_all, tmp_degs)
  rm(tmp_degs)
}

DEGs_all <- distinct(DEGs_all, gene_id)
saveRDS(object = DEGs_all, file = paste0("results/timepoint_specific_all_DEGs.RDS"))
```

Next move on to GSEA. 

### GSEA at each timepoint

Load hallmark pathways
```{r}
#load Human Molecular Signatures Database (msigdb) pathways
hallmark_pathways <- fgsea::gmtPathways("../../common-use-files/msigdb_pathways/h.all.v2023.2.Hs.symbols.gmt")
```

Loop through each timepoint following a similar process as done in the global analysis.
```{r}
#setup list to iterate through
timepoint_results_list <- list("T1" = `TimepointT1:InfectionMtb_results`, "T2" = `TimepointT2:InfectionMtb_results`, "T3" = `TimepointT3:InfectionMtb_results`, "T4" = `TimepointT4:InfectionMtb_results`, 
                               "T5" = `TimepointT5:InfectionMtb_results`, "T6" = `TimepointT6:InfectionMtb_results`, "T7" = `TimepointT7:InfectionMtb_results`, "T8" = `TimepointT8:InfectionMtb_results`, 
                               "T9" = `TimepointT9:InfectionMtb_results`, "T10" = `TimepointT10:InfectionMtb_results`, "T12" = `TimepointT12:InfectionMtb_results`, "T14" = `TimepointT14:InfectionMtb_results`, 
                               "T16" = `TimepointT16:InfectionMtb_results`, "T18" = `TimepointT18:InfectionMtb_results`, "T24" = `TimepointT24:InfectionMtb_results`, "T30" = `TimepointT30:InfectionMtb_results`, 
                               "T36" = `TimepointT36:InfectionMtb_results`, "T42" = `TimepointT42:InfectionMtb_results`, "T48" = `TimepointT48:InfectionMtb_results`)

#make dummy list
gsea_list <- list()

for (i in names(timepoint_results_list)) {
  #print element
  print(i)
  #assign to res
  res <- timepoint_results_list[[i]]
  #rank by t stat
  rank <- dplyr::arrange(res, t_statistic)
  #isolate symbol from gene_id - run distinct to make sure there are no duplicates
  rank <- mutate(rank, symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% distinct()
  #make rank vector
  rank_vec <- rank$t_statistic
  names(rank_vec) <- rank$symbol
  #run fgsea
  fgseaRes <- fgsea::fgsea(hallmark_pathways, rank_vec, nproc=1)
  #append to list
  gsea_list[[i]] <- fgseaRes
  #remove vars
  rm(res, rank, rank_vec, fgseaRes)
}
```

Select pathways with padj < 0.001 and a NES > +/- 1.5 in at least one timepoint. 
```{r}
select_top_pathways <- function(res) {
  sig <- as.data.frame(res) %>% dplyr::filter(padj < 0.001)
  top <- dplyr::filter(sig, NES > 1.5)
  bottom <- dplyr::filter(sig, NES < -1.5)
  return(dplyr::bind_rows(top, bottom))
}

gsea_sig_list <- lapply(gsea_list, FUN = select_top_pathways)

sig_pathways <- c(gsea_sig_list$T1$pathway, gsea_sig_list$T2$pathway, gsea_sig_list$T3$pathway, gsea_sig_list$T4$pathway, gsea_sig_list$T5$pathway, 
                  gsea_sig_list$T6$pathway, gsea_sig_list$T7$pathway, gsea_sig_list$T8$pathway, gsea_sig_list$T9$pathway, gsea_sig_list$T10$pathway,
                  gsea_sig_list$T12$pathway, gsea_sig_list$T14$pathway, gsea_sig_list$T16$pathway, gsea_sig_list$T18$pathway, gsea_sig_list$T24$pathway, 
                  gsea_sig_list$T30$pathway, gsea_sig_list$T36$pathway, gsea_sig_list$T42$pathway, gsea_sig_list$T48$pathway) %>% unique() %>% as.data.frame()
colnames(sig_pathways) <- "pathway"
```

Now that we have top pathways, extract NES from each timepoint and put into a dataframe
```{r}
for (i in c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48")) {
  #extract timepoint
  res <- gsea_list[[i]] %>% as.data.frame()
  #intersect with sig pathways
  res <- inner_join(res, sig_pathways, by = "pathway")
  #parse if fiirst time to add pathway
  if (i == "T1") {
    gsea_sig_df <- dplyr::transmute(res, pathway, !!i := NES)
  }
  if (i != "T1") {
  #add to a new column of df
    res <- dplyr::transmute(res, pathway, !!i := NES)
    gsea_sig_df <- left_join(gsea_sig_df, res, by = "pathway")
  }
  rm(res)
}
```

Pivot longer
```{r}
#order by mean NES
gsea_sig_df <- mutate(gsea_sig_df, mean_NES = rowMeans(across(-1))) %>%
  arrange(desc(mean_NES)) %>%
  select(1, everything()) %>% dplyr::select(-mean_NES)

#remove "hallmark_" from each pathway
gsea_sig_df <- mutate(gsea_sig_df, pathway = str_remove(pathway, "HALLMARK_"))

gsea_sig_df$pathway <- factor(gsea_sig_df$pathway, levels = rev(c(gsea_sig_df$pathway)))

gsea_sig_df <- pivot_longer(gsea_sig_df, cols = 2:last_col(), names_to = "Timepoint", values_to = "NES")

gsea_sig_df$Timepoint <- factor(gsea_sig_df$Timepoint, levels = c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48"))
```

Plot results as a heatmap with x=time, y=pathway, color=NES
```{r, fig.width=7.5, fig.height=8}
library(RColorBrewer)
my_palette <- colorRampPalette(rev(brewer.pal(11, "RdBu")))(50)

gsea_heatmap <- ggplot(gsea_sig_df, aes(x = Timepoint, y = pathway, fill = NES)) +
  geom_tile(color = "white", lwd = 0.5) +
  scale_fill_gradientn(colors = my_palette) +
  labs(title = "Gene Set Enrichment Analysis of Mtb Infection for each Timepoint",
       subtitle = "*only pathways with padj < 0.001 and a NES > +/- 1.5\nin at least one timepoint are shown",
       x = "Time Post-Infection (hrs)", 
       y = "Hallmark Pathways") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 12), 
        plot.subtitle = element_text(hjust = 0.5, face = "italic"), 
        axis.text.x = element_text(angle = 90, hjust = 1)) +
  coord_equal()

gsea_heatmap
```

### Clustering
We will cluster behaviors over time for the DEGs. We will do the following process:

1. With betas from each timepoint, extract only the genes that are differentially expressed in at least one timepoint. 
2. Mean center the mashed beta values. 
3. Then cluster either with kmeans and using an elbow plot to help chose cluster number. 
4. Assign cluster ids to each gene and then perform overrepresentation pathway analysis using all expressed genes as the universe. 

Prepare betas
```{r}
betas <- data.frame("T1" = `TimepointT1:InfectionMtb_results`$coefficients, "T2" = `TimepointT2:InfectionMtb_results`$coefficients, "T3" = `TimepointT3:InfectionMtb_results`$coefficients, 
                    "T4" = `TimepointT4:InfectionMtb_results`$coefficients, "T5" = `TimepointT5:InfectionMtb_results`$coefficients, "T6" = `TimepointT6:InfectionMtb_results`$coefficients, 
                    "T7" = `TimepointT7:InfectionMtb_results`$coefficients, "T8" = `TimepointT8:InfectionMtb_results`$coefficients, "T9" = `TimepointT9:InfectionMtb_results`$coefficients, 
                    "T10" = `TimepointT10:InfectionMtb_results`$coefficients, "T12" = `TimepointT12:InfectionMtb_results`$coefficients, "T14" = `TimepointT14:InfectionMtb_results`$coefficients, 
                    "T16" = `TimepointT16:InfectionMtb_results`$coefficients, "T18" = `TimepointT18:InfectionMtb_results`$coefficients, "T24" = `TimepointT24:InfectionMtb_results`$coefficients, 
                    "T30" = `TimepointT30:InfectionMtb_results`$coefficients, "T36" = `TimepointT36:InfectionMtb_results`$coefficients, "T42" = `TimepointT42:InfectionMtb_results`$coefficients, 
                    "T48" = `TimepointT48:InfectionMtb_results`$coefficients,
                    row.names = `TimepointT1:InfectionMtb_results`$gene_id) %>% as.matrix()
```


Intersect with all DEGs
```{r}
betas_degs <- betas[DEGs_all$gene_id, ]
nrow(betas_degs) # this should be 5106, if the intersection worked
```


#### Mean center betas

We do this with scale, which will center the data by subtracting the mean. We do not want scaling on. 
```{r}
betas_degs_mc <- apply(betas_degs, 1, function(x) scale(x, scale = FALSE, center = TRUE)) %>% t() %>% as.matrix()
colnames(betas_degs_mc) <- colnames(betas_degs) 
```

Checked the worked by plotting betas. There should be a normal distribution centered on 0. 
```{r}
hist(betas_degs, breaks = 100)
hist(betas_degs_mc, breaks = 100)
```

Sweet, it worked. 

#### Cluster Betas

Estimate the number of clusters
```{r}
library(factoextra)
library(cluster)

#elbow plot
elbow <- fviz_nbclust(x = betas_degs_mc, kmeans, method = "wss", k.max = 25) + geom_vline(xintercept = c(11), linetype = 2)
elbow
```

K=11 maybe looks the best. Try that one as well as 7. 

```{r}
set.seed(1993)
km_11 <- kmeans(betas_degs_mc, centers = 11, nstart = 50, iter.max = 100)
km_7 <- kmeans(betas_degs_mc, centers = 7, nstart = 50, iter.max = 100)
```

Add cluster information to betas:
```{r}
betas_degs_mc_clust <- mutate(as.data.frame(betas_degs_mc), Cluster_11 = km_11$cluster) %>% mutate(Cluster_7 = km_7$cluster)
```

#### Vizualize Clusters

##### Betas

Prepare df to plot beta by time for each cluster
```{r}
#add number of genes per cluster
n_11 <- count(betas_degs_mc_clust, Cluster_11) %>% dplyr::rename("n_11" = n)
n_7 <- count(betas_degs_mc_clust, Cluster_7) %>% dplyr::rename("n_7" = n)

#rownames to column
betas_degs_mc_clust <- rownames_to_column(betas_degs_mc_clust, "gene_id")

#join
betas_degs_mc_clust_n <- left_join(betas_degs_mc_clust, n_11, by = "Cluster_11")
betas_degs_mc_clust_n <- left_join(betas_degs_mc_clust_n, n_7, by = "Cluster_7")

#make long
betas_degs_mc_clust_long <- pivot_longer(betas_degs_mc_clust_n, cols = c(2:20), names_to = "timepoint", values_to = "mean_centered_beta")

#make timepoint_hr column
betas_degs_mc_clust_long <- mutate(betas_degs_mc_clust_long, timepoint_hr = str_remove(timepoint, pattern = "T"))

#change data types
betas_degs_mc_clust_long$timepoint_hr <- as.numeric(betas_degs_mc_clust_long$timepoint_hr)
betas_degs_mc_clust_long$Cluster_11 <- factor(betas_degs_mc_clust_long$Cluster_11)
betas_degs_mc_clust_long$Cluster_7 <- factor(betas_degs_mc_clust_long$Cluster_7)

#add "cluster_" before cluster_id
betas_degs_mc_clust_long <- mutate(betas_degs_mc_clust_long, Cluster_11 = paste0("Cluster ", Cluster_11))
betas_degs_mc_clust_long <- mutate(betas_degs_mc_clust_long, Cluster_7 = paste0("Cluster ", Cluster_7))

betas_degs_mc_clust_long$Cluster_11 <- factor(betas_degs_mc_clust_long$Cluster_11, levels = c("Cluster 11", "Cluster 4", "Cluster 1", "Cluster 10", "Cluster 2", "Cluster 8", "Cluster 7", "Cluster 6", "Cluster 3", "Cluster 9", "Cluster 5"))

betas_degs_mc_clust_long <- mutate(betas_degs_mc_clust_long, pattern = case_when(Cluster_11 %in% c("Cluster 11", "Cluster 4", "Cluster 1", "Cluster 10", "Cluster 2", "Cluster 8", "Cluster 7") ~ "Upregulated", 
                                                                                 Cluster_11 %in% c("Cluster 6", "Cluster 3", "Cluster 9", "Cluster 5") ~ "Downregulated"))
```

Plot k=11 clusters
```{r, fig.height=10, fig.width=10}
cluster_11_plot <- ggplot(betas_degs_mc_clust_long, aes(x = timepoint_hr, y=mean_centered_beta)) +
  geom_line(alpha = 0.1, size = 0.5, aes(group = gene_id)) +
  geom_smooth(method = "loess", lwd = 1.5, aes(color = Cluster_11)) +
  geom_text(aes(label = paste0("N = ", n_11)), x = Inf, y = Inf, hjust = 1.25, vjust = 2.5, color = "black") +
  geom_hline(yintercept = 0, linetype = "dashed", lwd = 1, color = "white") +
  facet_wrap(~Cluster_11, nrow = 4) +
  #scale_x_sqrt(breaks = unique(betas_degs_mc_clust_long$timepoint_hr)) +
  labs(title = "Behavior of kmeans clusters over time",
       x = "Timepoint", y = "Adjusted LogFC (Mtb/NI)", 
       subtitle = "*for differentially expressed genes only") +
  scale_color_viridis_d(option = "magma") +
  theme_bw() +
  theme(legend.position = "none", title = element_text(size = 8, face = "bold"), 
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5, face = "italic"),
    panel.background = element_rect(fill='transparent'), #transparent panel bg
    plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
    panel.grid.major = element_blank(), #remove major gridlines
    panel.grid.minor = element_blank(), #remove minor gridlines
    legend.background = element_rect(fill='transparent'), #transparent legend bg
    legend.box.background = element_rect(fill='transparent')) +
  coord_cartesian(ylim = c(-4,4))

cluster_11_plot
ggsave(cluster_11_plot, filename = "clusters.png", bg='transparent', height = 10, width = 10)
```

The clusters look pretty good. Some of them are similar, but we can reason they are all unique when you also consider magnitude differences. Nonetheless, lets also look at 7. 

Plot k=7 clusters
```{r, fig.height=15, fig.width=10}
cluster_7_plot <- ggplot(betas_degs_mc_clust_long, aes(x = timepoint_hr, y=mean_centered_beta)) +
  geom_jitter(alpha = 0.1, size = 0.5) +
  geom_smooth(method = "loess", lwd = 1) +
  geom_text(aes(label = paste0("N = ", n_7)), x = Inf, y = Inf, hjust = 1.25, vjust = 2.5, color = "black") +
  facet_wrap(~Cluster_7, ncol = 2, scales = "free_y") +
  scale_x_sqrt(breaks = unique(betas_degs_mc_clust_long$timepoint_hr)) +
  labs(title = "Behavior of kmeans clusters over time",
       x = "Timepoint", y = "Adjusted LogFC (Mtb/NI)", 
       subtitle = "*for differentially expressed genes only") +
  theme_bw() +
  theme(legend.position = "none", title = element_text(size = 8, face = "bold"), 
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5, face = "italic"))

cluster_7_plot
```

Personally, I like the k=11 better. I think we should go with that one. 

This is just the betas for each gene. Now let's add back the counts and see those trends. 

##### Counts
```{r}
tmp1 <- as.data.frame(v$E) %>% rownames_to_column("gene_id")
tmp2 <- betas_degs_mc_clust %>% rownames_to_column("gene_id")
voom_counts_DEGs_clusters <- left_join(tmp2, tmp1, by = "gene_id")
rm(tmp1, tmp2)

#drop betas and make long
voom_counts_DEGs_clusters_long <- voom_counts_DEGs_clusters[,-c(2:20)] %>%
  pivot_longer(cols = c(4:last_col()), names_to = "filename", values_to = "voom_cts")

#add metadata:
tmp <- rownames_to_column(sample_info, "filename")
voom_counts_DEGs_clusters_long <- left_join(voom_counts_DEGs_clusters_long, tmp, by = "filename")
rm(tmp)

#change data type
voom_counts_DEGs_clusters_long$Cluster_11 <- factor(voom_counts_DEGs_clusters_long$Cluster_11)

#add "cluster_" before cluster_id
voom_counts_DEGs_clusters_long <- mutate(voom_counts_DEGs_clusters_long, Cluster_11 = paste0("Cluster ", Cluster_11))

#reorder so up are on one side and down are on the other
voom_counts_DEGs_clusters_long$Cluster_11 <- factor(voom_counts_DEGs_clusters_long$Cluster_11, levels = c("Cluster 6", "Cluster 10", 
                                                                                                          "Cluster 4", "Cluster 1", 
                                                                                                          "Cluster 8", "Cluster 2", 
                                                                                                          "Cluster 11", "Cluster 5",
                                                                                                          "Cluster 7", "Cluster 3",
                                                                                                          "Cluster 9"))

#subsample and select up and down clusters
voom_counts_DEGs_clusters_long_sub <- dplyr::sample_frac(voom_counts_DEGs_clusters_long, 0.1)
```

Plot
```{r, fig.height=15, fig.width=10}
plot_smooth_counts_clust <- ggplot(voom_counts_DEGs_clusters_long_sub, aes(x = Timepoint_hr, y=voom_cts, color = Infection)) +
  geom_smooth(method = "loess", formula = y ~ x, lwd = 1, alpha = 0.3) +
  facet_wrap(~Cluster_11, ncol = 2, scales = "free_y") +
  scale_color_manual(values = c("grey", "#DB0000")) +
  scale_y_continuous(breaks = seq(-7,7,1)) +
  scale_x_sqrt(breaks = unique(betas_degs_mc_clust_long$timepoint_hr)) +
  labs(title = "Expression of kmeans clusters over time", 
       x = "Time After Infection (hr)", y = "Voom Transformed Counts",
       subtitle = "*only a random 10% subsample is shown for each") +
  theme_bw() +
  theme(legend.position = "bottom", title = element_text(size = 8, face = "bold"), 
        plot.title = element_text(hjust = 0.5), 
        plot.subtitle = element_text(hjust = 0.5))

plot_smooth_counts_clust
```


The counts validate the cluster behavior. The NI counts over time emphasize the advantage of a timepoint-matched approach. 

#### What pathways are specific to these clusters?
Pathway enrichment analysis. Use the expressed genes as the universe to identify unique pathways among each. 

```{r}
suppressPackageStartupMessages(library(clusterProfiler))
suppressPackageStartupMessages(library(ReactomePA))
suppressPackageStartupMessages(library(org.Hs.eg.db))

#get genes from each cluster
genes <- dplyr::select(betas_degs_mc_clust, gene_id, Cluster_11) %>%
  mutate(ensembl = str_split(gene_id, "_", simplify = T)[,1])

#get entrez_ids
ids <- bitr(genes$ensembl, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")

#join
genes <- left_join(genes, ids, by = c("ensembl" = "ENSEMBL"))
```

Get expressed genes
```{r}
#Read in genes
expr_genes <- readRDS('data/filtered_counts.rds') %>% row.names() %>% as.data.frame()
colnames(expr_genes) <- "gene_id"

#get ensembl
expr_genes <- mutate(expr_genes, ensembl = str_split(gene_id, "_", simplify = T)[,1])

#get entrez
expr_ids <- bitr(expr_genes$ensembl, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")

#join
expr_genes <- left_join(expr_genes, ids, by = c("ensembl" = "ENSEMBL"))

#assign
universe <- expr_genes$ENTREZID
```


Subset by cluster
```{r}
cluster_1 <- dplyr::filter(genes, Cluster_11 == 1)$ENTREZID
cluster_2 <- dplyr::filter(genes, Cluster_11 == 2)$ENTREZID
cluster_3 <- dplyr::filter(genes, Cluster_11 == 3)$ENTREZID
cluster_4 <- dplyr::filter(genes, Cluster_11 == 4)$ENTREZID
cluster_5 <- dplyr::filter(genes, Cluster_11 == 5)$ENTREZID
cluster_6 <- dplyr::filter(genes, Cluster_11 == 6)$ENTREZID
cluster_7 <- dplyr::filter(genes, Cluster_11 == 7)$ENTREZID
cluster_8 <- dplyr::filter(genes, Cluster_11 == 8)$ENTREZID
cluster_9 <- dplyr::filter(genes, Cluster_11 == 9)$ENTREZID
cluster_10 <- dplyr::filter(genes, Cluster_11 == 10)$ENTREZID
cluster_11 <- dplyr::filter(genes, Cluster_11 == 11)$ENTREZID
```

Since I have the info, save the genes within each cluster for ancestry analysis: 
```{r}
dplyr::filter(genes, Cluster_11== 1)$gene_id %>% saveRDS(file = "results/DEGs_cluster_1.RDS")
dplyr::filter(genes, Cluster_11 == 2)$gene_id %>% saveRDS(file = "results/DEGs_cluster_2.RDS")
dplyr::filter(genes, Cluster_11 == 3)$gene_id %>% saveRDS(file = "results/DEGs_cluster_3.RDS")
dplyr::filter(genes, Cluster_11 == 4)$gene_id %>% saveRDS(file = "results/DEGs_cluster_4.RDS")
dplyr::filter(genes, Cluster_11 == 5)$gene_id %>% saveRDS(file = "results/DEGs_cluster_5.RDS")
dplyr::filter(genes, Cluster_11 == 6)$gene_id %>% saveRDS(file = "results/DEGs_cluster_6.RDS")
dplyr::filter(genes, Cluster_11 == 7)$gene_id %>% saveRDS(file = "results/DEGs_Cluster_7.RDS")
dplyr::filter(genes, Cluster_11 == 8)$gene_id %>% saveRDS(file = "results/DEGs_Cluster_8.RDS")
dplyr::filter(genes, Cluster_11 == 9)$gene_id %>% saveRDS(file = "results/DEGs_Cluster_9.RDS")
dplyr::filter(genes, Cluster_11 == 10)$gene_id %>% saveRDS(file = "results/DEGs_Cluster_10.RDS")
dplyr::filter(genes, Cluster_11 == 11)$gene_id %>% saveRDS(file = "results/DEGs_Cluster_11.RDS")
```

Run analysis for up and down clusters seperately and order by which turn on fastest
```{r}
up_clusters <- list("cluster 11" = cluster_11, 
                 "cluster 4" = cluster_4,
                 "cluster 1" = cluster_1,
                 "cluster 10" = cluster_10,
                 "cluster 2" = cluster_2,
                 "cluster 8" = cluster_8, 
                 "cluster 7" = cluster_7)

down_clusters <- list("cluster 6" = cluster_6, 
                 "cluster 3" = cluster_3,
                 "cluster 9" = cluster_9,
                 "cluster 5" = cluster_5)

up_reactome <- clusterProfiler::compareCluster(geneClusters = up_clusters, fun = enrichPathway, universe = universe)
up_kegg <- clusterProfiler::compareCluster(geneClusters = up_clusters, fun = enrichKEGG, universe = universe)
up_bp <- clusterProfiler::compareCluster(geneClusters = up_clusters, fun = enrichGO, universe = universe, OrgDb = org.Hs.eg.db, ont = "BP", keyType = "ENTREZID")

down_reactome <- clusterProfiler::compareCluster(geneClusters = down_clusters, fun = enrichPathway, universe = universe)
down_kegg <- clusterProfiler::compareCluster(geneClusters = down_clusters, fun = enrichKEGG, universe = universe)
down_bp <- clusterProfiler::compareCluster(geneClusters = down_clusters, fun = enrichGO, universe = universe, OrgDb = org.Hs.eg.db, ont = "BP", keyType = "ENTREZID")
```

Plot
```{r, fig.height=6, fig.width=8}
plot_up_reactome <- dotplot(up_reactome, showCategory = 4) + ggtitle("Reactome Pathway Enrichment for Upregulated Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))
plot_up_kegg <- dotplot(up_kegg, showCategory = 4) + ggtitle("KEGG Pathway Enrichment for Upregulated Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))
plot_up_bp <- dotplot(up_bp, showCategory = 4) + ggtitle('Gene Onology Enrichment for Upregulated Clusters vs. DEGs', subtitle = "Biological Process Terms" ) +
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))

plot_down_reactome <- dotplot(down_reactome, showCategory = 4) + ggtitle("Reactome Pathway Enrichment for Downregulated Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))
plot_down_kegg <- dotplot(down_kegg, showCategory = 4) + ggtitle("KEGG Pathway Enrichment for Downregulated Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))
plot_down_bp <- dotplot(down_bp, showCategory = 4) + ggtitle('Gene Onology Enrichment for Downregulated Clusters vs. DEGs', subtitle = "Biological Process Terms" ) +
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))


plot_up_reactome
plot_up_kegg
plot_up_bp

plot_down_reactome
plot_down_kegg
plot_down_bp
```

It is not as clean as I would like. I will now repeat but use the whole protein coding genome as the universe. 


```{r}
#get pc genes
pc_gene_ids <- plyranges::filter(gtf, type == 'gene', gene_biotype == 'protein_coding') %>% as.data.frame() %>% dplyr::select(gene_id, gene_name)

#get entrez_ids for pc_genes
pc_ids <- bitr(pc_gene_ids$gene_id, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")
```
```{r}
#set universe to all protein coding genes
universe <- pc_ids$ENTREZID
```

Run analysis
```{r}
up_reactome <- clusterProfiler::compareCluster(geneClusters = up_clusters, fun = enrichPathway, universe = universe)
up_kegg <- clusterProfiler::compareCluster(geneClusters = up_clusters, fun = enrichKEGG, universe = universe)
up_bp <- clusterProfiler::compareCluster(geneClusters = up_clusters, fun = enrichGO, universe = universe, OrgDb = org.Hs.eg.db, ont = "BP", keyType = "ENTREZID")

down_reactome <- clusterProfiler::compareCluster(geneClusters = down_clusters, fun = enrichPathway, universe = universe)
down_kegg <- clusterProfiler::compareCluster(geneClusters = down_clusters, fun = enrichKEGG, universe = universe)
down_bp <- clusterProfiler::compareCluster(geneClusters = down_clusters, fun = enrichGO, universe = universe, OrgDb = org.Hs.eg.db, ont = "BP", keyType = "ENTREZID")
```

Plot
```{r, fig.height=6, fig.width=8}
plot_up_reactome <- dotplot(up_reactome, showCategory = 3) + ggtitle("Reactome Pathway Enrichment for Upregulated Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50)) + theme(axis.text.x = element_text(angle = 90))
plot_up_kegg <- dotplot(up_kegg, showCategory = 5) + ggtitle("KEGG Pathway Enrichment for Upregulated Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50)) + theme(axis.text.x = element_text(angle = 90))
plot_up_bp <- dotplot(up_bp, showCategory = 5) + ggtitle('Gene Onology Enrichment for Upregulated Clusters vs. DEGs', subtitle = "Biological Process Terms" ) +
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50)) + theme(axis.text.x = element_text(angle = 90))

plot_down_reactome <- dotplot(down_reactome, showCategory = 3) + ggtitle("Reactome Pathway Enrichment for Downregulated Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50)) + theme(axis.text.x = element_text(angle = 90))
plot_down_kegg <- dotplot(down_kegg, showCategory = 5) + ggtitle("KEGG Pathway Enrichment for Downregulated Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50)) + theme(axis.text.x = element_text(angle = 90))
plot_down_bp <- dotplot(down_bp, showCategory = 5) + ggtitle('Gene Onology Enrichment for Downregulated Clusters vs. DEGs', subtitle = "Biological Process Terms" ) +
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50)) + theme(axis.text.x = element_text(angle = 90))


plot_up_reactome
plot_up_kegg
plot_up_bp

plot_down_reactome
plot_down_kegg
plot_down_bp
```

So far it seems like we are able to identify 7 patterns and these represent distinct functions of the immune response. 

It seems like cluster 1, the rebound cluster is the initial response as it yields TLR4 pathways. 

Cluster 2 is a small response and contains genes involved in the inital response as well as the secondary response. Temporally it is a little faster than cluster 7, but somewhat slower than cluster 1. I'm not sure what to make of cluster 2, it seems to be one of the less important clusters.

Cluster 7 is the robust transcriptional response and is secondary to the response in cluster 1. This seems to be among the most functionally important clusters to me. 

Cluster 4 seems to be the tertiary response and contains genes for ECM related pathways, such as collagen growth.

For the down regulated clusters, cluster 6 is the inital response and is hihgly specific to the RHO, RAC1, and CDC42 GTPase patthways. This is very cool because phagocytosis involves these pathways and it would make sense that the bacteria is trying to inhibit phagocytosis. This seems like a critically important cluster as well. 

Cluster 3 are genes that are rapidly downregulated but persist and they are cell cycle factors. Very unsure of how to interpret these other than maybe the infection tells the cell to stop cycling. These iPSC-MFs do cycle and the analysis we have says they do. The cell cycle analysis also says that they cycle slower after infection.  

Cluster 5 are anti-viral genes. It seems like maybe the cells commit to antibacterial pathways and therefore turn off antiviral ones. This makes sense, but I need to do more research to see if this is true. This is a later response. 




## Save relevant plots
```{r, eval = FALSE}
#ggsave(plot = all_gsea_plot, filename = "results/plots_infection_vs_time_batch1-only/global_gsea.pdf", device = cairo_pdf, height = 8, width = 10)
#ggsave(plot = mf_regs_plot, filename = "results/plots_infection_vs_time_batch1-only/macrophage_genes_expr-vs-time.pdf", device = cairo_pdf, height = 20, width = 8)
#ggsave(plot = cell_cycle_plot, filename = "results/plots_infection_vs_time_batch1-only/cell-cycle_genes_expr-vs-time.pdf", device = cairo_pdf, height = 20, width = 8)
#ggsave(plot = degs_plot_mash, filename = "results/plots_infection_vs_time_batch1-only/number_degs_per_timepoint_mash.pdf", device = cairo_pdf, height = 5, width = 8)
#ggsave(plot = gsea_heatmap, filename = "results/plots_infection_vs_time_batch1-only/gsea_per_timepoint.pdf", device = cairo_pdf, height = 8, width = 7.5)
#ggsave(plot = elbow, filename = "results/plots_infection_vs_time_batch1-only/elbow_plot.pdf", device = cairo_pdf, height = 5, width = 8)
#ggsave(plot = clusters_plot, filename = "results/plots_infection_vs_time_batch1-only/cluster_behavior.pdf", device = cairo_pdf, height = 14, width = 8)
#ggsave(plot = plot_up_reactome, filename = "results/plots_infection_vs_time_batch1-only/cluster_reactome_up_all-pc-genes.pdf", device = cairo_pdf, height = 6, width = 8)
#ggsave(plot = plot_down_reactome, filename = "results/plots_infection_vs_time_batch1-only/cluster_reactome_up_down-pc-genes.pdf", device = cairo_pdf, height = 6, width = 8)
#ggsave(plot = plot_smooth_counts_clust_up, filename = "results/plots_infection_vs_time_batch1-only/clusters_counts_smooth_up.pdf", device = cairo_pdf, height = 14, width = 4)
#ggsave(plot = plot_smooth_counts_clust_down, filename = "results/plots_infection_vs_time_batch1-only/clusters_counts_smooth_down.pdf", device = cairo_pdf, height = 11, width = 4)
```


## Session Info
```{r}
sessionInfo()
```

