---
title: "Linear modeling of RNA-seq data with Limma-Voom: Infection vs. Time"
output: html_notebook
---
Author: Tyler Hansen
Date: 5.23.2024

This notebook specifically looks at the effect of the infection for all timepoints and this effect at each timepoint. Ancestry relate analysis will come later. Importantly, this only uses batch1 samples, sinc batch2 were deemed poor. 

In the previous notebook, I tried to identify how best to model my data. 

I will model the infection at each timepoint using a nested model (Timepoint:Infection). 

I will then identify DEGs per timepoint and report. 

I will then extract betas from each timepoint, mean-center them, and then cluster by their behavior using hclust and kmeans. I will then run pathway enrichment overrepresentation analysis on the individual clusters to see which pathways they represent. 

## Setup

Packages
```{r}
suppressPackageStartupMessages(library(tidyverse))
library(limma)
library(edgeR)
```

Three tables
```{r}
#read in GTF
gtf <- rtracklayer::readGFFAsGRanges("data/Homo_sapiens.GRCh38.87.gtf")

#read in cts
cts <- readRDS("data/filtered_counts_final_batch1.rds")

#read in si
sample_info <- readRDS("data/metadata_final_batch1.rds")
```

## Model infection:

Model: ~ Infection:Timepoint + Timepoint + Donor_ID + RNA_concentration + perc_Dups + flow_cell + M_Aligned

Altogether, this model can be interpreted this way:
1) TimepointT2 is the effect of TimepointT2 on gene expression relative to T1 (T2-T1) - "intrinsic timepoint effects"
2) Donor_IDAF193 is the effect of Donor AF193 relative to AF183 - "intrinsic donor effects"
3) flow_cell2 is the effect of flow cell 2 relative to 1 - "intrinsic flow cell effects"
4) RNA_concentration is the effect of RNA concentration on gene expression
5) perc_Dups is the effect of percent duplicates on gene expression
6) M_Aligned is the effect of percent mito DNA on gene expression
7) InfectionMtb:TimepointT1 is the effect of Mtb infection on gene expression at Timepoint 1

Number 7 and alike terms are the values we will extract and identify genes with a significant effect as infection DEGs. 

### Read in sample info and set design

I want to model the infection, to identify genes that respond to infection at all timepoints across all donors. The covariates here are GC, Dups, Aligned, and flow_cell.
```{r}
#set design matrix. 
design <- model.matrix(~ Infection:Timepoint + Timepoint + Donor_ID + RNA_concentration + perc_Dups + flow_cell + M_Aligned, sample_info)
```

### Voom transform
Now that the counts are filtered, perform the voom tramsformation. 
```{r, fig.height=3, fig.width=4}
#if match, then this will print true
all(rownames(design) == colnames(cts))

#make dgelist again and voom transform
dge <- DGEList(cts)
dge <- calcNormFactors(dge)
v <- voom(dge, design, plot = T)
```

### Fit model and compute empirical bayes statistics for contrasts
```{r}
#fit model
vfit <-lmFit(v, design)

#compute stats
vfit <- eBayes(vfit)
```

### Check that model is working per timepoint

Set up list of Infection:Timepoint coefficient terms
```{r}
#set timepoints
timepoints <- c("T1","T2","T3","T4","T5","T6","T7","T8","T9","T10","T12","T14","T16","T18","T24","T30","T36","T42","T48")

#get list of terms for infection
infection_beta_list <- list()
for (t in timepoints) {
  beta <- paste0("InfectionMtb:Timepoint", t)
  infection_beta_list <- append(infection_beta_list, beta)
  rm(beta)
}
```

For each coefficient, get the top 6 genes using top table and plot voom counts
```{r, fig.width = 12, fig.height=4}
for (i in infection_beta_list) {
    #get top hits
  tmp <- topTable(vfit, coef = i, number = 6)
  
  #make df of voom counts for each gene and each condition. 
  tmp <- v$E[row.names(tmp), ] %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  pivot_longer(cols = !gene_id, names_to = "sample", values_to = "voom_cts") %>% 
    left_join(rownames_to_column(sample_info, var = "sample"), by = "sample") %>% 
    mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% dplyr::filter(Timepoint == str_extract(i, "(?<=Timepoint)T\\d+"))
  
  #plot
  p <- ggplot(tmp, aes(x = Infection, y = voom_cts)) +
    geom_jitter(aes(color = Infection), alpha = 0.5) +
    geom_boxplot(aes(fill = Infection), alpha = 0.5, outlier.alpha = 0) +
    facet_wrap(~symbol, ncol = 6, scales = "free") +
    ggtitle(paste0("Top 6 genes for ", i, " coefficient")) +
    scale_fill_manual(values = c("grey", "red")) +
    scale_color_manual(values = c("grey", "red")) +
    theme_bw()
  
  print(p)
  
  #save plot
  pdf(file = paste0("results/batch1_only/infection_DEGs/top_genes_boxplots/", str_extract(i, "(?<=Timepoint)T\\d+"), ".pdf"), height = 4, width = 12, family = "ArialMT")
  print(p)
  dev.off()
}
```


## Compute emperical p values and apply the story fdr correction to these values
The q value adjustment for multiple testing correction seems to be the superior method to FWER and Benjamini-Hochberg. The only issue with it is when the pvalue distribution is not uniform. In most cases, this is fine, but it is best to use an empirical approach where the pvalues are first corrected based on null pvalues obtained from permutations. 

To do this, we have the following steps:
1. Permute the variable of interest and calculate the null pvalues, for at least 10 iterations.
2. Adjust the observed pvalues based on the null/expected pvalues using the emPvals() function from the qvalue package. 
3. Use the adjusted p values to calculate storey q values. Use these to threshold genes. 

### Permute the variable of interest and calculate the null pvalues, for at least 10 iterations. 
Permute the the infection column so that infection is randomly distributed in sample info and the null is the random effect of that. 
```{r}
permute_si_vars <- function(permuted_var, si, n) {
  #permute the variable of interest
  x <- rsample::permutations(si, permute = all_of(permuted_var), times = n)
  
  # create dummy list
  list_x <- list()
  
  #extract each iteration and set_up random models:
  for (i in seq(1, n)) {
    #extract permuted ith iteration
    si_rand <- x$splits[[i]] %>% rsample::analysis() %>% as.data.frame()
    
    #add to list
    list_x <- rlist::list.append(list_x, si_rand)
  }

  #return list
  return(list_x)
}
```

```{r}
#set seed so random generation is reproducible
set.seed(1993)

#execute function:
perms <- permute_si_vars("Infection", si = sample_info, n = 200)
```

Fit permuted data to linear models, use the same model as done in the observed analysis
```{r}
fit_permutations <- function(perms, formula, v) {
  # perms is the permuted sample info
  # formula is the formula used in the respective analysis provided in quotes (ex: "~ Timepoint")
  # v are the voom tramsformed counts to input into the random/null models. 
  # Returns a list of model fits for the permuted data
  
  # create dummy list
  list_x <- list()
  
  #extract each iteration and set_up random models:
    for (i in seq(1, length(perms))) {
      message(i)
      #set up model for ith iteration
      m_rand <- model.matrix(as.formula(formula), data = as.data.frame(perms[i]))
    
      #fit model for each iteration
      vfit_rand <- lmFit(v, m_rand)
      
      #compute stats
      vfit_rand <- eBayes(vfit_rand)
      
      #add to list
      list_x <- rlist::list.append(list_x, vfit_rand)
    }
  return(list_x)
}
```

```{r}
permuted_fits <- fit_permutations(perms = perms, formula = "~ Infection:Timepoint + Timepoint + Donor_ID + RNA_concentration + perc_Dups + flow_cell + M_Aligned", v = v)
```

Calculate null pvalues
```{r}
get_null_pvals <- function(perm_fits) {
  # perm_fits is the list of model fits for permuted data 
  # cat is the category/variable that was permuted within (must be a factor). This is used to identify the individual categories to get pvalues for. 
  # Returns a vector of pvalues for the contrast between Mtb and NI
  
  # create dummy df
  df <- data.frame()
  
  #for each iteration, extract the null pvalues between NI and Mtb:
    for (i in seq(1, length(perm_fits))) {
      #for each iteration, append p.vals to the dummy df
      x <- as.data.frame(perm_fits[[i]]$p.value)
      df <- dplyr::bind_rows(df, x)
    }
  return(df)
}
```

```{r}
null_pvalues <- get_null_pvals(perm_fits = permuted_fits)
```

Check the distribution of null pvalues
```{r}
hist(as.matrix(null_pvalues)[, 37:55])
hist(vfit$p.value[, 37:55])
```

For each timepoint, calculate p-values from a set of observed test statistics and null test statistics. 

Note: the the pvals are -log10 transformed so that stat(obs) is greater than stat0(null)

```{r}
#make pval df
obs_pvals <- as.data.frame(vfit$p.value)

#setup results list
results_list <- list()

#run through list to extract qvalues for each
for (i in infection_beta_list) {
  emperical_pvals <- qvalue::empPvals(stat = -log10(obs_pvals[, i]), stat0 = -log10(null_pvalues[, i]), pool = T)
  qvals <- qvalue::qvalue(p = emperical_pvals)
  
  #merge
  tmp1 <- data.frame(obs_pval = obs_pvals[, i], empirical_pval = emperical_pvals, qval = qvals$qvalues)
  
  #get pvalues just for the timepoint
  tmp2 <- dplyr::select(obs_pvals, all_of(i))
  colnames(tmp2) <- "p.value"
  
  #join to each gene
  tmp3 <- bind_cols(tmp2, tmp1) %>% rownames_to_column("gene_id")
  
  #stop if the row order is not the same
  if (all(tmp3$p.value == tmp3$obs_pval) == FALSE) {
    stop()
  }
  
  #remove redundant col
  tmp3 <- dplyr::select(tmp3, -p.value)
  
  #get the stats
  tmp4 <- data.frame(coefficients = c(vfit$coefficients[, i]), 
                     t_statistic = c(vfit$t[, i]), 
                     p.value = c(vfit$p.value[, i])) %>% rownames_to_column("gene_id")
  
  #join
  tmp5 <- inner_join(tmp4, tmp3, by = "gene_id")
  
  #stop if join doesn't work properly
  if (all(tmp5$p.value == tmp5$obs_pval) == FALSE) {
    stop()
  }
  #remove redundant col 
  tmp5 <- dplyr::select(tmp5, -obs_pval)

  #append
  results_list[[i]] <- tmp5
  
  #remove tmps
  rm(tmp1, tmp2, tmp3, tmp4, tmp5)
}
```

## Number of DEGs per timepoint
We will threshold with qval and effect size.

Plot distributions to make an educated choice on the thresholds. 

qvalues
```{r}
#get all qvalues
tmp <- data.frame(dummy=1:11181)
for (i in infection_beta_list) {
tmp[[i]] <- results_list[[i]]$qval %>% as.numeric()
}
tmp <- tmp[,-1] %>% as.matrix()
hist(tmp, breaks = 100)
abline(v = c(0.01))
rm(tmp)
```

Probably 0.01 is the best q val threshold. 

effect sizes
```{r}
#get all qvalues
tmp <- data.frame(dummy=1:11181)
for (i in infection_beta_list) {
tmp[[i]] <- results_list[[i]]$coefficients %>% as.numeric()
}
tmp <- tmp[,-1] %>% as.matrix()
hist(tmp, breaks = 100)
abline(v = c(-1, +1))
rm(tmp)
```

Report number of DEGs via qval and +/-1 coefficient
```{r}
degs_df <- data.frame()
for (i in infection_beta_list) {
timepoint <- str_extract(i, "(?<=TimepointT)\\d+") %>% as.numeric()
number_DEGs <- dplyr::filter(results_list[[i]], qval < 0.01 & abs(coefficients) > 1) %>% nrow()
tmp <- data.frame(timepoint = timepoint, number_DEGs = number_DEGs)
degs_df <- rbind(degs_df, tmp)
rm(tmp)
}

```

Plot
```{r, fig.width=5, fig.height=4}
degs_plot <- ggplot(degs_df, aes(x = timepoint, y = number_DEGs, group = 1)) +
  geom_smooth(color = "purple") +
  geom_line(color="grey20", linetype = "dashed") +
  geom_point(size = 3) +
  #geom_text(aes(label = number_DEGs), vjust = 0, hjust=-0.2, angle = 75) +
  scale_x_continuous(breaks = seq(0,48,4)) +
  scale_y_continuous(breaks = seq(0,4e3, 1000)) +
  labs(y = "Number of DEGs", x  ="Timepoint (hrs)",
       title = "Number of Infection DEGs", 
       subtitle = "q-value < 0.001") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 10), plot.subtitle = element_text(hjust = 0.5, face = "italic", size = 8)) +
  coord_cartesian(ylim = c(0, 4e3))

degs_plot

pdf(file = "results/batch1_only/infection_DEGs/DEGs_perTimepoint.pdf", height = 4, width = 5, family = "ArialMT")
degs_plot
dev.off()
```

Save results_list for future use.
```{r}
saveRDS(object = results_list, file = paste0("results/batch1_only/infection_DEGs/infection_per_timepoint_DE_results.RDS"))
```

Next move on to GSEA. 

## GSEA at each timepoint

Load hallmark pathways
```{r}
#load Human Molecular Signatures Database (msigdb) pathways
hallmark_pathways <- fgsea::gmtPathways("../../common-use-files/msigdb_pathways/h.all.v2023.2.Hs.symbols.gmt")
```

Loop through each timepoint.
```{r}
#make dummy list
hallmark_gsea_list <- list()

for (i in infection_beta_list) {
  #get timepoint
  tmp0 <- str_extract(i, "(?<=TimepointT)\\d+") %>% as.numeric()
  
  #assign timepoint specific result to tmp1
  tmp1 <- results_list[[i]]
  
  #rank by t stat
  tmp2 <- dplyr::arrange(tmp1, t_statistic)
  
  #isolate symbol from gene_id - run distinct to make sure there are no duplicates
  tmp3 <- mutate(tmp2, symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% distinct(symbol, .keep_all = T)
  
  #make rank vector
  tmp4 <- tmp3$t_statistic
  names(tmp4) <- tmp3$symbol
  
  #run fgsea for hallmark
  tmp5 <- fgsea::fgsea(hallmark_pathways, tmp4, nproc = 1)
  
  #append to list
  hallmark_gsea_list[[as.character(tmp0)]] <- tmp5
  
  #remove vars
  rm(tmp0, tmp1, tmp2, tmp3, tmp4, tmp5)
}
```

Select pathways with padj < 0.001 and a NES > +/- 1.5 in at least one timepoint. 
```{r}
#function
select_top_pathways <- function(res) {
  sig <- as.data.frame(res) %>% dplyr::filter(padj < 0.001)
  top <- dplyr::filter(sig, NES > 2)
  bottom <- dplyr::filter(sig, NES < -2)
  return(dplyr::bind_rows(top, bottom))
}

#apply function to all of the elements of the list
gsea_sig_list <- lapply(hallmark_gsea_list, FUN = select_top_pathways)

#get all significant pathways for plotting
sig_pathways <- c()
for (i in c(1:10,12,14,16,18,24,30,36,42,48)) {
  tmp <- gsea_sig_list[[as.character(i)]]$pathway
  sig_pathways <- append(sig_pathways, tmp)
}

sig_pathways <- unique(sig_pathways) %>% as.data.frame()
colnames(sig_pathways) <- "pathway"
```

Now that we have top pathways, extract NES from each timepoint and put into a dataframe
```{r}
for (i in c(1:10,12,14,16,18,24,30,36,42,48)) {
  #extract timepoint
  res <- hallmark_gsea_list[[as.character(i)]] %>% as.data.frame()
  #intersect with sig pathways
  res <- inner_join(res, sig_pathways, by = "pathway")
  #parse if fiirst time to add pathway
  if (i == 1) {
    gsea_sig_df <- dplyr::transmute(res, pathway, !!as.character(i) := NES)
  }
  if (i != 1) {
  #add to a new column of df
    res <- dplyr::transmute(res, pathway, !!as.character(i) := NES)
    gsea_sig_df <- left_join(gsea_sig_df, res, by = "pathway")
  }
  rm(res)
}
```

Pivot longer
```{r}
#order by mean NES
gsea_sig_df <- mutate(gsea_sig_df, mean_NES = rowMeans(across(-1))) %>%
  arrange(desc(mean_NES)) %>%
  select(1, everything()) %>% dplyr::select(-mean_NES)

#remove "hallmark_" from each pathway
gsea_sig_df <- mutate(gsea_sig_df, pathway = str_remove(pathway, "HALLMARK_"))

gsea_sig_df$pathway <- factor(gsea_sig_df$pathway, levels = rev(c(gsea_sig_df$pathway)))

gsea_sig_df <- pivot_longer(gsea_sig_df, cols = 2:last_col(), names_to = "Timepoint", values_to = "NES")

gsea_sig_df$Timepoint <- factor(gsea_sig_df$Timepoint, levels = c("1","2","3","4","5","6","7","8","9","10","12","14","16","18","24","30","36","42","48"))
```

Plot results as a heatmap with x=time, y=pathway, color=NES
```{r, fig.width=8, fig.height=6}
library(RColorBrewer)
my_palette <- colorRampPalette(rev(brewer.pal(11, "RdBu")))(50)

gsea_heatmap <- ggplot(gsea_sig_df, aes(x = Timepoint, y = pathway, fill = NES)) +
  geom_tile(color = "white", lwd = 0.25) +
  scale_fill_gradientn(colors = my_palette) +
  labs(title = "Gene Set Enrichment Analysis of Mtb Infection for each Timepoint",
       subtitle = "*only hallmark pathways with padj < 0.001 and NES < +/-1\nfor at least one timepoint are shown",
       x = "Time Post-Infection (hrs)", 
       y = "Hallmark Pathways") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 12), 
        plot.subtitle = element_text(hjust = 0.5, face = "italic"), 
        axis.text.x = element_text(angle = 90, hjust = 1)) +
  coord_equal()


gsea_heatmap

#save
pdf(file = "results/batch1_only/infection_DEGs/GSEA_heatmap_perTimepoint.pdf", height = 8, width = 6, family = "ArialMT")
gsea_heatmap
dev.off()
```

This is pretty cool. There are some interesting dynamic behaviors here that I want to investigate further. Also, I want to see how genes within the top terms TNFA_SIGNALING_VIA_NFKB and OXIDATIVE_PHOSPHORYLATION are responding. The best way I can think of is to extract the gene_ids from these terms and make a hierachical clustered heatmap of response (logFC of Mtb/NI voom counts) over time for each pathway. 

### Expr vs. time heatmaps of response for genes within each pathway

Here are the pathways I want to explore:
TNFA_SIGNALING_VIA_NFKB
OXIDATIVE_PHOSPHORYLATION
INTERFERON_GAMMA_RESPONSE
INTERFERON_ALPHA_RESPONSE
INFLAMMATORY_RESPONSE
COMPLEMENT
MYC_TARGETS_V1
E2F_TARGETS
P53_PATHWAY
G2M_CHECKPOINT
TGF_BETA_SIGNALING

Let's get this to work for TNFA_SIGNALING_VIA_NFKB first and then loop or function it.

Use voom counts here so the plotted values are true measures, not what is being modeled by our coefs.

Join to pathway specific genes
```{r}
#set pathway
i <- "TNFA_SIGNALING_VIA_NFKB"

#Get gene symbols from hallmark pathways object
pathway_genes <- data.frame("symbol" = hallmark_pathways[[paste0("HALLMARK_", i)]])

#intersect genes with voom counts, but first convert rownames to column and remove ensemble portion
pathway_counts <- as.data.frame(v$E) %>% rownames_to_column("gene_id") %>% mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% inner_join(x = pathway_genes, by = "symbol")
```

There are NAs. Presumably for genes were filtered out. Change left join to inner join to fix this. 

Add metadata and collapse by timepoint+condition, then calculate foldchange
```{r}
#lengthen so samples are one column
pathway_df <- pivot_longer(pathway_counts, cols = 3:last_col(), names_to = "samples", values_to = "counts")

#join with SI, only the Timepoint & Infection
pathway_df <- dplyr::select(sample_info, Timepoint, Infection, Donor_ID) %>% rownames_to_column("samples") %>% left_join(x = pathway_df, by = "samples")

#widen so NI and Mtb have their own columns
pathway_df <- dplyr::select(pathway_df, -samples) %>% pivot_wider(names_from = "Infection", values_from = "counts")

#calculate foldchange for each timepoint for each donor. The data is already log2 transformed, so we need to subtract Mtb from NI rather than doing Mtb/NI. 
pathway_df <- mutate(pathway_df, log2FC = Mtb-NI)

#average logFC for each gene within each condition within each timepoint. I verified this actually calculates the mean. 
pathway_df_summary <- group_by(pathway_df, symbol, Timepoint) %>% summarize(mean_log2FC = mean(log2FC), .groups = "drop")
```

Convert to matrix where columns are timepoints (in order), rows are genes, and values are foldchanges
```{r}
#remove extra columns and widen
pathway_matrix <- pivot_wider(pathway_df_summary, names_from = "Timepoint", values_from = "mean_log2FC", names_sort = T)

#assign genes to rownames and set as matrix then log the values
pathway_matrix <- column_to_rownames(pathway_matrix, "symbol") %>% as.matrix() %>% t()
```

Use pheatmap to cluster and plot a pretty heatmap
```{r}
library(pheatmap)
```

```{r, fig.height=6, fig.width=25}
my_palette <- colorRampPalette(rev(brewer.pal(11, "RdBu")))(50)

#set color scate by getting min, max, and mid values 
min_val <- -12
max_val <- 12

# Generate breaks with the midpoint at 0
breaks <- c(seq(min_val, max_val, length.out=51))

#plot
heatmap <- pheatmap(pathway_matrix, cluster_rows = F, cluster_cols = T, color = my_palette, scale = "none", breaks = breaks)

#save
pdf(file = "results/HALLMARK_pathway_heatmaps/TNFA_signaling_via_NFKB.pdf", width = 25, height = 6, family = "ArialMT")
heatmap
dev.off()
```

This is really cool. It allows us to see what is happeneing within the pathways. Here, we can see the terms are dominated by the intensely high cluster containing IL1-alpha. 

Now iterate and apply to all of the pathways I want. 
```{r, fig.height=6, fig.width=25}
#Get counts
pathway_list <- list("TNFA_SIGNALING_VIA_NFKB", "OXIDATIVE_PHOSPHORYLATION", "INTERFERON_GAMMA_RESPONSE", "INTERFERON_ALPHA_RESPONSE", "INFLAMMATORY_RESPONSE", "COMPLEMENT", "MYC_TARGETS_V1", "E2F_TARGETS", "P53_PATHWAY", "G2M_CHECKPOINT", "TGF_BETA_SIGNALING")

for (i in pathway_list) {
  #print iteration
  print(i)
  
  #Get gene symbols from hallmark pathways object
  tmp <- data.frame("symbol" = hallmark_pathways[[paste0("HALLMARK_", i)]])
  
  #intersect genes with voom counts, but first convert rownames to column and remove ensemble portion
  tmp <- as.data.frame(v$E) %>% rownames_to_column("gene_id") %>% mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>% inner_join(x = tmp, by = "symbol")
  
  #lengthen so samples are one column
  tmp <- pivot_longer(tmp, cols = 3:last_col(), names_to = "samples", values_to = "counts")
  
  #join with SI, only the Timepoint & Infection
  tmp <- dplyr::select(sample_info, Timepoint, Infection, Donor_ID) %>% rownames_to_column("samples") %>% left_join(x = tmp , by = "samples")
  
  #widen so NI and Mtb have their own columns
  tmp <- dplyr::select(tmp, -samples) %>% pivot_wider(names_from = "Infection", values_from = "counts")
  
  #calculate foldchange for each timepoint for each donor. The data is already log2 transformed, so we need to subtract Mtb from NI rather than doing Mtb/NI. 
  tmp <- mutate(tmp, log2FC = Mtb-NI)
  
  #average logFC for each gene within each condition within each timepoint. I verified this actually calculates the mean. 
  tmp <- group_by(tmp, symbol, Timepoint) %>% summarize(mean_log2FC = mean(log2FC), .groups = "drop")
  
  #remove extra columns and widen
  tmp <- pivot_wider(tmp, names_from = "Timepoint", values_from = "mean_log2FC", names_sort = T)
  
  #assign genes to rownames and set as matrix then log the values
  tmp <- column_to_rownames(tmp, "symbol") %>% as.matrix() %>% t()
  
  #set color scate by getting min, max, and mid values 
  min_val <- -1 * max(tmp)
  max_val <- max(tmp)
  
  # Generate breaks with the midpoint at 0
  breaks <- c(seq(min_val, max_val, length.out=51))
  
  #plot
  tmp <- pheatmap(tmp, cluster_rows = F, cluster_cols = T, color = my_palette, scale = "none", breaks = breaks, main=i)
  
  #save
  pdf(file = paste0("results/HALLMARK_pathway_heatmaps/", i, ".pdf"), width = 25, height = 6, family = "ArialMT")
  tmp
  dev.off()
}
```


## Find dynamic genes
Try identifying the most dynamic genes by getting the cumulative absolute values of timepoint to timepoint deltas. 

For this we want to look at corrected expression for the genes we identify as differentially expressed at at least one timepoint. 

First get the DEGs: 
```{r}
get_DEGs <- function(i) {
  DEGs <- dplyr::filter(i, qval < 0.01 & abs(coefficients) > 1)
  return(DEGs)
}

DEGs_list <- lapply(results_list, get_DEGs)
```

Get gene ids of all DEGs called for at least one timepoint.
```{r}
DEGs_vector <- c()
for (i in DEGs_list) {
  tmp <- dplyr::select(i, gene_id) %>% mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2))
  DEGs_vector <- append(DEGs_vector, tmp$symbol)
}

#covert to df and remove duplicate gene ids
DEGs_dataframe <- as.data.frame(DEGs_vector) %>% distinct()
```


Create a df that has avg fold change per timepoint for each gene (like the heatmaps above but for all genes).
```{r}
response_df <- as.data.frame(v$E) %>% rownames_to_column("gene_id") %>% 
  mutate(symbol = str_split_i(gene_id, pattern = "_", i = 2)) %>%
  relocate(symbol, .after = gene_id) %>%
  pivot_longer(cols = 3:last_col(), names_to = "samples", values_to = "counts")

#join to metadata and keep tidying  
response_df <- dplyr::select(sample_info, Timepoint, Infection, Donor_ID) %>% 
  rownames_to_column("samples") %>% 
  left_join(x = response_df, by = "samples") %>% 
  dplyr::select(-samples) %>% 
  pivot_wider(names_from = "Infection", values_from = "counts") %>%
  mutate(log2FC = Mtb-NI) %>%
  group_by(symbol, Timepoint) %>% 
  summarize(mean_log2FC = mean(log2FC), .groups = "drop")
  
#remove extra columns and widen
response_df <- pivot_wider(response_df, names_from = "Timepoint", values_from = "mean_log2FC", names_sort = T) %>%
  column_to_rownames("symbol")
```

Subset for DEGs from above
```{r}
response_df_degs <- response_df[DEGs_dataframe$DEGs_vector, ]
```


Calculate a "dynamic score" that is the sum of the absolute difference between timepoints. Also save the difference. 
```{r}
dynamic_gene_scores <- as.data.frame(matrix(nrow = 0, ncol = 19))
colnames(dynamic_gene_scores) <- c("dynamic_score", "abs_T1-T2", "abs_T2-T3", "abs_T3-T4", "abs_T4-T5", "abs_T5-T6", "abs_T6-T7", "abs_T7-T8", "abs_T8-T9", "abs_T9-T10", "abs_T10-T12", "abs_T12-T14", "abs_T14-T16", "abs_T16-T18", "abs_T18-T24", "abs_T24-T30", "abs_T30-T36", "abs_T36-T42", "abs_T42-T48")

for (row in 1:nrow(response_df_degs)) {
  abs_diffs <- response_df_degs[row,] %>% as.matrix() %>% as.numeric() %>% diff() %>% abs() %>% as.data.frame() %>% t()
  diffs <- response_df_degs[row,] %>% as.matrix() %>% as.numeric() %>% diff() %>% as.data.frame() %>% t()
  sum <- sum(abs_diffs) %>% as.data.frame()
  res <- cbind(sum, diffs)
  colnames(res) <- c("dynamic_score", "abs_T1-T2", "abs_T2-T3", "abs_T3-T4", "abs_T4-T5", "abs_T5-T6", "abs_T6-T7", "abs_T7-T8", "abs_T8-T9", "abs_T9-T10", "abs_T10-T12", "abs_T12-T14", "abs_T14-T16", "abs_T16-T18", "abs_T18-T24", "abs_T24-T30", "abs_T30-T36", "abs_T36-T42", "abs_T42-T48")
  rownames(res) <- rownames(response_df_degs[row,])
  dynamic_gene_scores <- bind_rows(dynamic_gene_scores, res)
}
```

Now plot dynamic scores for DEGs to see if there is anything intersting
```{r}
#histogram
hist(dynamic_gene_scores$dynamic_score, breaks = 100)

#rank vs effect plot
dynamic_gene_scores_rank <- mutate(dynamic_gene_scores, rank = row_number(dynamic_gene_scores))

plot(dynamic_gene_scores_rank$rank, dynamic_gene_scores$dynamic_score)
abline(v = 5750)
```

There seems to be a large increase in the top 100 genes. Threshold here and plot the patterns over time. 

```{r}
top_dynamic_genes <- dplyr::filter(dynamic_gene_scores_rank, rank > 5770) %>% dplyr::arrange(rank)
```

```{r, fig.width=8, fig.height=12}
library(RColorBrewer)
my_palette <- colorRampPalette(rev(brewer.pal(11, "RdBu")))(50)

#set color scate by getting min, max, and mid values 
min_val <- -1 * max(top_dynamic_genes[,2:19])
max_val <- max(top_dynamic_genes[,2:19])
  
# Generate breaks with the midpoint at 0
breaks <- c(seq(min_val, max_val, length.out=51))

#plot
heatmap <- pheatmap((top_dynamic_genes[,2:19]), cluster_cols = F, cluster_rows = T, color = my_palette, scale = "none", breaks = breaks)
```

This wasn't all that informative. 

## Cluster genes into response trajectories 

Below, we will cluster differentially expressed genes using Hierarchical clustering. The benefit of running hclust is it is easier to determine how many clusters to pick based on the dendrogram. 

We need to get the coefficients for each gene from each timepoint. We then need to z-score them so they are centered around zero and corrected for magnitude differences. 

### Setup
Get coefficient from each gene for each timepoint
```{r}
for (t in infection_beta_list) {
  #print the timepoint
  print(t)
  #get coefs for all genes from the iterated timepoint
  tmp <- results_list[[t]] %>% dplyr::select(gene_id, coefficients)
  #get gene symbols and set as rownames
  tmp <- mutate(tmp, symbol = str_split_i(gene_id, pattern = "_", i = 2))
  #filter for DEGs
  tmp <- filter(tmp, symbol %in% DEGs_dataframe$DEGs_vector)
  #add column specifying timepoint
  tmp <- mutate(tmp, timepoint = str_extract(t, "(?<=Timepoint)T\\d+"))
  #bind to dataframe
  if (t == "InfectionMtb:TimepointT1") {
    DEG_coefs <- tmp
  }
  else {
    DEG_coefs <- bind_rows(DEG_coefs, tmp)
  }
}

#widen so timepoint is columns, gene_id is rows, and value is coefs
DEG_coefs_matrix <- dplyr::select(DEG_coefs, -symbol) %>% pivot_wider(names_from = timepoint, values_from = coefficients) %>% column_to_rownames("gene_id") %>% as.matrix()
```

z-score each gene
```{r}
DEG_coefs_zscore <- apply(DEG_coefs_matrix, 1, function(x) scale(x, scale = TRUE, center = TRUE)) %>% t() %>% as.matrix()
colnames(DEG_coefs_zscore) <- colnames(DEG_coefs_matrix) 
```

Checked the worked by plotting the values. There should be a normal distribution centered on 0. 
```{r}
hist(DEG_coefs_matrix, breaks = 100)
hist(DEG_coefs_zscore, breaks = 100)
```

Sweet, it worked. Run Hclust. 

### Hclust
```{r}
#create distance matrix
DEG_coefs_dist <- dist(DEG_coefs_zscore, method = "euclidean")

#use hclust to cluster
set.seed(1993)
clusters <- hclust(DEG_coefs_dist, method = "complete")
```

View dendrogram
```{r, fig.width=20, fig.height=8}
plot(clusters, labels = F)
```

Based on the tree, 11 clusters looks right to me.

Call clusters and add to matrix to annotate genes. 
```{r}
#cut tree
clusterCut <- cutree(clusters, 11)

#Add cluster information to betas:
all(rownames(clusterCut) == rownames(DEG_coefs_zscore))
DEG_coefs_clust_wide <- mutate(as.data.frame(DEG_coefs_zscore), cluster_id = clusterCut)
```

How many in each cluster?
```{r}
for (i in 1:11) {
  print(i)
  dplyr::filter(DEG_coefs_clust_wide, cluster_id == i) %>% nrow() %>% print()
}
```


#### Hclust heatmap
Make a heatmap of the clusters using pheatmap. Heatmap color are z-scored infection betas. 
```{r, fig.height=6, fig.width=7.5}
#set color scate by getting min, max, and mid values 
min_val <- -1 * max(abs(DEG_coefs_zscore))
max_val <- max(abs(DEG_coefs_zscore))
  
#Generate breaks with the midpoint at 0
breaks <- c(seq(min_val, max_val, length.out=51))

#annotation
anno <- data.frame(clusters = DEG_coefs_clust_wide$cluster_id)
anno$clusters <- factor(anno$clusters)

#annotation colors
anno_palette <- list(clusters = c("1"="#FBB4AE", "2"="#B3CDE3", "3"="#CCEBC5", "4"="#DECBE4", "5"="#FED9A6", "6"="#FFFFCC", "7"="#E5D8BD", "8"="#FDDAEC", "9"="#F2F2F2", "10" = "grey60", "11" = "grey30"))

#plot
p <- pheatmap::pheatmap(DEG_coefs_zscore, cluster_cols = F, cluster_rows = T, color = my_palette, scale = "none", breaks = breaks, clustering_method = "complete", show_rownames = F, clustering_distance_rows = "euclidean", treeheight_row = 150, cutree_rows = 11, annotation_row = anno, annotation_legend = T, annotation_names_row = F, annotation_colors = anno_palette, fontsize = 12, main = "Hierarchical Clustering of Mtb-Responsive Genes", border_color = NA)

#save
pdf(file = "results/batch1_only/infection_DEGs/hclust_heatmap.pdf", height = 6, width = 7.5, family = "ArialMT")
p
dev.off()
```

This looks great. I think 11 is the right number of clusters. 

### Vizualize clusters with voom count data

The above heatmap is very nice for understanding the behavior of the clusters, but it is looking at heavily transformed values. I want to see how this would look if we just plot Log2FC(Mtb-NI) from the voom count data. 

Extract gene-cluster pairs
```{r}
gene_clustID_df <- data.frame(cluster_id = DEG_coefs_clust_wide$cluster_id) %>% rownames_to_column("gene_id")
```

Construct a matrix of logFC values where rows = gene and col = timepoint
```{r}
#lengthen the counts matrix so cols are filenames and their values are the counts
voom_counts_long <- as.data.frame(v$E) %>% rownames_to_column("gene_id") %>% pivot_longer(cols = 2:last_col(), names_to = "filename", values_to = "voom_counts")

#add information from SI
voom_counts_long <- left_join(voom_counts_long, rownames_to_column(sample_info, "filename")[, c(1,2,3,5)], by = "filename")

#drop filename
voom_counts_long <- dplyr::select(voom_counts_long, -filename)

#widen so infection is two columns and values are vooom counts
voom_counts_wide <- pivot_wider(voom_counts_long, names_from = "Infection", values_from = "voom_counts")

#calculate log2FC by subtracting Mtb from NI (this is done because they are already Log2 transformed)
voom_counts_wide <- mutate(voom_counts_wide, L2FC = Mtb - NI)

#average L2FC across donors for each gene and timepoint
voom_counts_wide <- group_by(voom_counts_wide, gene_id, Timepoint) %>% summarise(mean_L2FC = mean(L2FC), .groups = "drop")

#convert into a matrix so that col is timepoint and values are mean_L2FC
voom_counts_matrix <- pivot_wider(voom_counts_wide, names_from = "Timepoint", values_from = "mean_L2FC")

#join with cluster id using inner join to get DEGs only and order gene_ids by cluster ids. 
voom_counts_matrix <- inner_join(voom_counts_matrix, gene_clustID_df, by = "gene_id") %>% dplyr::arrange(cluster_id)

#set cluster id as anno
anno <- data.frame(clusters = voom_counts_matrix$cluster_id, row.names = voom_counts_matrix$gene_id)
anno$clusters <- factor(anno$clusters)

#remove cluster id from voom matrix and set gene ID to rownames
voom_counts_matrix <- dplyr::select(voom_counts_matrix, -cluster_id) %>% column_to_rownames("gene_id") %>% as.matrix()
```

Use pheatmap without clustering to plot voom count L2FC.
```{r, fig.height=6, fig.width=7.5}
#set color scate by getting min, max, and mid values 
min_val <- -1 * max(abs(voom_counts_matrix))
max_val <- max(abs(voom_counts_matrix))
  
#Generate breaks with the midpoint at 0
breaks <- c(seq(min_val, max_val, length.out=51))

#plot
p <- pheatmap::pheatmap(voom_counts_matrix, cluster_cols = F, cluster_rows = F, color = my_palette, scale = "row", breaks = breaks, show_rownames = F, annotation_row = anno, annotation_legend = T, annotation_names_row = F, annotation_colors = anno_palette, fontsize = 10, main = "Hierarchical Clustering of Mtb-Responsive Genes - L2FC voom counts", border_color = NA)

#save
pdf(file = "results/batch1_only/infection_DEGs/hclust_heatmap__voomcounts.pdf", height = 6, width = 7.5, family = "ArialMT")
p
dev.off()
```

I had to scale (z-score) the rows to make it look pretty like this. 

Now lets plot line plots where each line is a gene and it is faceted by cluster. X = timepoint. Y = mean_L2FC.

Start from voom_counts_matrix. z-score L2FC values by row. Then lengthen so timepoint is one column and l2fc is another column. Then add cluster_id
```{r}
#z-score matrix
voom_counts_zscore <- apply(voom_counts_matrix, 1, function(x) scale(x, scale = TRUE, center = TRUE)) %>% t() %>% as.data.frame()
colnames(voom_counts_zscore) <- colnames(voom_counts_matrix) 

#lengthen
voom_counts_zscore <- rownames_to_column(voom_counts_zscore, "gene_id") %>% pivot_longer(cols = 2:last_col(), names_to = "Timepoint", values_to = "z-score_L2FC")

#add cluster_id
voom_counts_zscore <- left_join(voom_counts_zscore, gene_clustID_df, by = "gene_id")

#remove T from timepoint
voom_counts_zscore$Timepoint <- str_remove(voom_counts_zscore$Timepoint, "T") %>% as.numeric()

#factorize cluster_id
voom_counts_zscore$cluster_id <- factor(voom_counts_zscore$cluster_id)
```

Plot
```{r, fig.height=6, fig.width=8}
cluster_plot <- ggplot(voom_counts_zscore, aes(x = Timepoint, y=`z-score_L2FC`)) +
  geom_line(alpha = 0.1, size = 0.5, aes(group = gene_id)) +
  geom_smooth(method = "loess", lwd = 1.5, aes(color = cluster_id)) +
  geom_hline(yintercept = 0, linetype = "dashed", lwd = 1, color = "white") +
  facet_wrap(~cluster_id, nrow = 3, ncol = 4) +
  labs(title = "Cluster behaviors over time",
       x = "Timepoint", y = "z-score of Log2(Mtb/NI)", 
       subtitle = "*values are from voom counts and only differentially expressed genes were clustered") +
  scale_color_viridis_d(option = "magma", begin = 0.4) +
  theme_bw(base_size = 12) +
  theme(legend.position = "none", title = element_text(size = 8, face = "bold"), 
        plot.title = element_text(hjust = 0.5, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5, face = "italic"),
    panel.background = element_rect(fill='transparent'), #transparent panel bg
    plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
    panel.grid.major = element_blank(), #remove major gridlines
    panel.grid.minor = element_blank(), #remove minor gridlines
    legend.background = element_rect(fill='transparent'), #transparent legend bg
    legend.box.background = element_rect(fill='transparent')) +
  coord_cartesian(ylim = c(-4,4))

cluster_plot

#save
pdf(file = "results/batch1_only/infection_DEGs/hclust_clusters_voom-counts.pdf", height = 6, width = 8, family = "ArialMT")
cluster_plot
dev.off()
```

This is cool. The clusters look pretty good. Let's look at reactome pathway enrichment. 

#### Pathway enrichment analysis. 
Use the expressed genes as the universe to identify unique pathways among each. 

```{r}
suppressPackageStartupMessages(library(clusterProfiler))
suppressPackageStartupMessages(library(ReactomePA))
suppressPackageStartupMessages(library(org.Hs.eg.db))

#get geneid and cluster_id
genes <- rownames_to_column(DEG_coefs_clust_wide, "gene_id") %>% dplyr::select(gene_id, cluster_id) %>%
  mutate(ensembl = str_split(gene_id, "_", simplify = T)[,1])

#get entrez_ids
ids <- bitr(genes$ensembl, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")

#join
genes <- left_join(genes, ids, by = c("ensembl" = "ENSEMBL"), relationship = "many-to-many")
```

Get expressed genes
```{r}
#Read in genes
expr_genes <- readRDS('data/filtered_counts.rds') %>% row.names() %>% as.data.frame()
colnames(expr_genes) <- "gene_id"

#get ensembl
expr_genes <- mutate(expr_genes, ensembl = str_split(gene_id, "_", simplify = T)[,1])

#get entrez
expr_ids <- bitr(expr_genes$ensembl, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")

#join
expr_genes <- left_join(expr_genes, ids, by = c("ensembl" = "ENSEMBL"))

#assign
universe <- expr_genes$ENTREZID
```


Subset by cluster
```{r}
#make empty list
cluster_list <- list()

#iterate over cluster number appending each cluster to the list
for (i in 1:11) {
  tmp <- dplyr::filter(genes, cluster_id == i)$ENTREZID
  cluster_list[[paste0("cluster ", i)]] <- tmp
  rm(tmp)
}
```

Since I have the info, save the genes within each cluster for downstream analysis: 
```{r}
saveRDS(cluster_list, file = "results/DEGs_cluster_list_hclust.RDS")
```

Run analysis
```{r}
reactome <- clusterProfiler::compareCluster(geneClusters = cluster_list, fun = enrichPathway, universe = universe, pvalueCutoff = 0.5, qvalueCutoff = 0.7)
kegg <- clusterProfiler::compareCluster(geneClusters = cluster_list, fun = enrichKEGG, universe = universe, pvalueCutoff = 1, qvalueCutoff = 1)
bp <- clusterProfiler::compareCluster(geneClusters = cluster_list, fun = enrichGO, universe = universe, OrgDb = org.Hs.eg.db, ont = "BP", keyType = "ENTREZID", pvalueCutoff = 0.5, qvalueCutoff = 0.7)
mf <- clusterProfiler::compareCluster(geneClusters = cluster_list, fun = enrichGO, universe = universe, OrgDb = org.Hs.eg.db, ont = "MF", keyType = "ENTREZID", pvalueCutoff = 0.5, qvalueCutoff = 0.7)
cc <- clusterProfiler::compareCluster(geneClusters = cluster_list, fun = enrichGO, universe = universe, OrgDb = org.Hs.eg.db, ont = "CC", keyType = "ENTREZID", pvalueCutoff = 0.5, qvalueCutoff = 0.7)
```

Plot
```{r, fig.height=10, fig.width=15}
dotplot(reactome, showCategory = 6) + ggtitle("Reactome Pathway Enrichment: Genes within Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))

dotplot(kegg, showCategory = 6) + ggtitle("KEGG Pathway Enrichment: Genes within Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))

dotplot(bp, showCategory = 6) + ggtitle("Gene Ontology - BP enrichment: Genes within Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))

dotplot(mf, showCategory = 6) + ggtitle("Gene Ontology - MF enrichment: Genes within Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))

dotplot(cc, showCategory = 6) + ggtitle("Gene Ontology - CC enrichment: Genes within Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))
```

I think the KEGG plot is the most informative, save that one. 
```{r}
pdf(file = "results/batch1_only/clusters_KEGG_enrichhment_hclust.pdf", width = 15, height = 10, family = "ArialMT")
dotplot(kegg, showCategory = 8) + ggtitle("KEGG Pathway Enrichment: Genes within Clusters vs. DEGs")+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50))
dev.off()
```

For presentation purposes, I want to just show a handful of pathways:

MAPK signaling pathway
NF-Kappa B signaling pathway
Oxidative phosphorylation
Fc epsilon RI signaling pathway
C-type lectin receptor signaling pathway
TGF-beta signaling pathway
Cellular senescence

```{r, fig.width=8, fig.height=3}
#define pathways
select_pathways <- c("MAPK signaling pathway",
"NF-kappa B signaling pathway",
"Oxidative phosphorylation",
"Ribosome biogenesis in eukaryotes",
"C-type lectin receptor signaling pathway",
"ECM-receptor interaction",
"TGF-beta signaling pathway",
"DNA replication",
"Cellular senescence", 
"HIF-1 signaling pathway",
"FoxO signaling pathway")

#select pathways from result
select_kegg <- as.data.frame(kegg) %>% dplyr::filter(Description %in% select_pathways)

#transform to factor
select_kegg$Description <- factor(select_kegg$Description, levels = rev(select_pathways))

#calculate GeneRatio
select_kegg <- mutate(select_kegg, num = str_extract(GeneRatio, "^[0-9]+")) %>% mutate(denom = str_extract(GeneRatio, "(?<=/)[0-9]+")) %>% mutate(GeneRatio_numeric = as.numeric(num)/as.numeric(denom))

#plot dotplot
select_kegg_plot <- ggplot(select_kegg, aes(color = p.adjust, size = GeneRatio_numeric, y = Description, x = Cluster)) +
  geom_point() +
  scale_color_gradientn(colors = rev(c(RColorBrewer::brewer.pal(9, "BuPu"))),  na.value = "white", name = "p.adjust") +
  scale_size_continuous(breaks = c(0,0.025,0.05,0.075,0.1)) +
  labs(size = "GeneRatio") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90), 
        axis.title = element_blank())

select_kegg_plot

pdf(file = "results/batch1_only/clusters_KEGG_enrichhment_select_hclust.pdf", width = 8, height = 3, family = "ArialMT")
select_kegg_plot
dev.off()
```


In addition to this, I want to show the behavior of a few genes over time. 

## Example Genes

Let's do TNF, IL-6, IL1A, CD80, and CDC45

Get counts: convert voom counts 
```{r}
v_counts_symbol <- v$E %>% as.data.frame() %>% rownames_to_column(var = "gene_id") %>% 
  mutate(gene_id = str_split_i(gene_id, pattern = "_", i = 2)) %>% 
  dplyr::distinct(gene_id, .keep_all = T) %>% 
  column_to_rownames(var = "gene_id")
```

Set list of genes to analyze. 
```{r}
analysis_genes <- list("TNF",
"IL6",
"IL1A",
"CD80", 
"MCM2")
```


Loop through list of genes producing a plot of expression over time with values for each condition and ancestry plotted separately.
```{r, fig.width=5, fig.height=4}
for (i in analysis_genes) {

tmp1 <- v_counts_symbol[i,] %>% as.data.frame() %>% rownames_to_column("gene_id") %>%
  pivot_longer(cols = 2:last_col(), names_to = "sample", values_to = "counts") %>% 
  left_join(rownames_to_column(sample_info, var = "sample"), by = "sample")

tmp2 <- ggplot(tmp1, aes(x = as.factor(Timepoint_hr), y = counts, fill = Infection)) +
  geom_boxplot(outliers = F, alpha = 0.8, lwd = 0.25) +
  scale_fill_manual(values = c("grey", "firebrick")) +
  ylab("Log2 Expression") +
  ggtitle(i) +
  theme_bw(base_size = 8)

print(tmp2)

pdf(file = paste0("results/batch1_only/infection_DEGs/example_genes/", i, "_expr_vs_time.pdf"), width = 5, height = 4, family = "ArialMT")
print(tmp2)
dev.off()

rm(tmp1, tmp2)
}

```


## Session Info
```{r}
sessionInfo()
```
